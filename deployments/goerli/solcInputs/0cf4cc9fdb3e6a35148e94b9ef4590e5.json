{
  "language": "Solidity",
  "sources": {
    "contracts/alert/CollateralBalanceValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../depositary/IDepositaryBalanceView.sol\";\nimport \"./IValidator.sol\";\n\ncontract CollateralBalanceValidator is IValidator, Ownable {\n    using SafeMath for uint256;\n\n    /// @notice Accuracy of permissible imbalance.\n    uint256 public constant PERMISSIBLE_DECIMALS = 2;\n\n    /// @notice Address of stable token.\n    ERC20 public stableToken;\n\n    /// @notice Address of collateral.\n    IDepositaryBalanceView public collateral;\n\n    /// @notice Permissible imbalance of stable token total supply and collateral balance.\n    uint256 public permissibleImbalance;\n\n    /// @notice An event thats emitted when stable token address updated.\n    event StableTokenUpdated(address newStableToken);\n\n    /// @notice An event thats emitted when collateral address updated.\n    event CollateralUpdated(address newCollateral);\n\n    /// @notice An event thats emitted when permissible imbalance updated.\n    event PermissibleImbalanceUpdated(uint256 newPermissibleImbalance);\n\n    /**\n     * @param _stableToken Address of stable token.\n     * @param _collateral Address of collateral.\n     * @param _permissibleImbalance Permissible imbalance of stable token total supply and collateral balance.\n     */\n    constructor(\n        address _stableToken,\n        address _collateral,\n        uint256 _permissibleImbalance\n    ) public {\n        stableToken = ERC20(_stableToken);\n        collateral = IDepositaryBalanceView(_collateral);\n        permissibleImbalance = _permissibleImbalance;\n    }\n\n    /**\n     * @param _stableToken New stable token address.\n     */\n    function changeStableToken(address _stableToken) external onlyOwner {\n        require(_stableToken != address(0), \"CollateralBalanceValidator::changeStableToken: invalid stable token address\");\n\n        stableToken = ERC20(_stableToken);\n        emit StableTokenUpdated(_stableToken);\n    }\n\n    /**\n     * @param _collateral New collateral address.\n     */\n    function changeCollateral(address _collateral) external onlyOwner {\n        require(_collateral != address(0), \"CollateralBalanceValidator::changeCollateral: invalid collateral address\");\n\n        collateral = IDepositaryBalanceView(_collateral);\n        emit CollateralUpdated(_collateral);\n    }\n\n    /**\n     * @param _permissibleImbalance New permissible imbalance value.\n     */\n    function changePermissibleImbalance(uint256 _permissibleImbalance) external onlyOwner {\n        permissibleImbalance = _permissibleImbalance;\n        emit PermissibleImbalanceUpdated(_permissibleImbalance);\n    }\n\n    function validate() external view override returns (bool) {\n        uint256 stableTotalSupply = stableToken.totalSupply();\n        uint256 stableTokenDecimals = stableToken.decimals();\n        uint256 collateralBalance = collateral.balance();\n        uint256 collateralDecimals = collateral.decimals();\n\n        if (stableTokenDecimals > collateralDecimals) {\n            collateralBalance = collateralBalance.mul(10**(stableTokenDecimals - collateralDecimals));\n        } else if (collateralDecimals > stableTokenDecimals) {\n            stableTotalSupply = stableTotalSupply.mul(10**(collateralDecimals - stableTokenDecimals));\n        }\n\n        return collateralBalance.mul(10**PERMISSIBLE_DECIMALS).div(stableTotalSupply).add(permissibleImbalance) >= 100;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/depositary/IDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title The Depositary Balance interface.\n */\ninterface IDepositaryBalanceView {\n    /**\n     * @notice Get decimals balance.\n     * @return Decimals balance.\n     */\n    function decimals() external view returns(uint256);\n\n    /**\n     * @notice Get balance of depositary.\n     * @return Balance of depositary.\n     */\n    function balance() external view returns(uint256);\n}"
    },
    "contracts/alert/IValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IValidator {\n    /**\n     * @notice Validate protocol state.\n     * @return Is state valid.\n     */\n    function validate() external view returns(bool);\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/alert/ProtocolValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"./IValidator.sol\";\n\ncontract ProtocolValidator is Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice The number of validators in agregate.\n    uint256 public maxSize;\n\n    /// @dev Protocol contracts list.\n    EnumerableSet.AddressSet internal protocolContracts;\n\n    /// @notice Validator and controlled contract (zero address for all protocol contracts).\n    mapping(address => address) public validators;\n\n    /// @dev Validators list.\n    EnumerableSet.AddressSet internal validatorsIndex;\n\n    /// @notice An event thats emitted when protocol contract added.\n    event ProtocolContractAdded(address newContract);\n\n    /// @notice An event thats emitted when protocol contract removed.\n    event ProtocolContractRemoved(address removedContract);\n\n    /// @notice An event thats emitted when validator added.\n    event ValidatorAdded(address validator, address controlledContract);\n\n    /// @notice An event thats emitted when validator removed.\n    event ValidatorRemoved(address validator);\n\n    /// @notice An event thats emitted when state invalid.\n    event InvalidState(address validator, address controlledContract);\n\n    /**\n     * @param _maxSize Maximal count of protocol contracts and validators.\n     */\n    constructor(uint256 _maxSize) public {\n        maxSize = _maxSize;\n    }\n\n    /**\n     * @return Validators count of agregate.\n     */\n    function size() public view returns (uint256) {\n        return validatorsIndex.length().add(protocolContracts.length());\n    }\n\n    /**\n     * @param _contract Protocol contract address.\n     */\n    function addProtocolContract(address _contract) external onlyOwner {\n        require(_contract != address(0), \"ProtocolValidator::addProtocolContract: invalid contract address\");\n        require(protocolContracts.contains(_contract) || size() < maxSize, \"ProtocolValidator::addProtocolContract: too many protocol contracts\");\n\n        protocolContracts.add(_contract);\n        emit ProtocolContractAdded(_contract);\n    }\n\n    /**\n     * @param _contract Protocol contract address.\n     */\n    function removeProtocolContract(address _contract) external onlyOwner {\n        require(_contract != address(0), \"ProtocolValidator::removeProtocolContract: invalid contract address\");\n\n        protocolContracts.remove(_contract);\n        emit ProtocolContractRemoved(_contract);\n    }\n\n    /**\n     * @return Addresses of all protocol contracts.\n     */\n    function protocolContractsList() external view returns (address[] memory) {\n        address[] memory result = new address[](protocolContracts.length());\n\n        for (uint256 i = 0; i < protocolContracts.length(); i++) {\n            result[i] = protocolContracts.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @param validator Validator address.\n     * @param controlledContract Pausable contract address (zero address for all protocol contracts).\n     */\n    function addValidator(address validator, address controlledContract) external onlyOwner {\n        require(validator != address(0), \"ProtocolValidator::addValidator: invalid validator address\");\n        require(validatorsIndex.contains(validator) || size() < maxSize, \"ProtocolValidator::addValidator: too many validators\");\n\n        validators[validator] = controlledContract;\n        validatorsIndex.add(validator);\n        emit ValidatorAdded(validator, controlledContract);\n    }\n\n    /**\n     * @param validator Validator address.\n     */\n    function removeValidator(address validator) external onlyOwner {\n        require(validator != address(0), \"ProtocolValidator::removeValidator: invalid validator address\");\n\n        validators[validator] = address(0);\n        validatorsIndex.remove(validator);\n        emit ValidatorRemoved(validator);\n    }\n\n    /**\n     * @return Validators addresses list.\n     */\n    function validatorsList() external view returns (address[] memory) {\n        address[] memory result = new address[](validatorsIndex.length());\n\n        for (uint256 i = 0; i < validatorsIndex.length(); i++) {\n            result[i] = validatorsIndex.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Pause contract or all protocol contracts.\n     * @param controlledContract Paused contract (zero address for all protocol contracts).\n     */\n    function _pause(address controlledContract) internal {\n        if (controlledContract == address(0)) {\n            for (uint256 i = 0; i < protocolContracts.length(); i++) {\n                _pause(protocolContracts.at(i));\n            }\n        } else {\n            OwnablePausable target = OwnablePausable(controlledContract);\n            address pauser = target.pauser();\n            require(pauser == address(this), \"ProtocolValidator::_pause: target contract not control\");\n            bool paused = target.paused();\n\n            if (!paused) {\n                target.pause();\n            }\n        }\n    }\n\n    /**\n     * @notice Validate protocol state and pause controlled contract if state invalid.\n     * @param validator Target validator.\n     * @return Is state valid.\n     */\n    function validate(address validator) external returns (bool) {\n        require(validatorsIndex.contains(validator), \"ProtocolValidator::validate: validator not found\");\n\n        bool isValid = IValidator(validator).validate();\n        if (!isValid) {\n            _pause(validators[validator]);\n            emit InvalidState(validator, validators[validator]);\n        }\n\n        return isValid;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/utils/OwnablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\ncontract OwnablePausable is Ownable, Pausable {\n    /// @notice Address that can pause a contract.\n    address public pauser;\n\n    /// @notice An event thats emitted when an pauser address changed.\n    event PauserChanged(address newPauser);\n\n    constructor() internal {\n        pauser = owner();\n    }\n\n    /**\n     * @notice Change pauser account.\n     * @param newPauser Address of new pauser account.\n     */\n    function changePauser(address newPauser) external onlyOwner {\n        pauser = newPauser;\n        emit PauserChanged(pauser);\n    }\n\n    /**\n     * @notice Triggers stopped state.\n     */\n    function pause() public virtual {\n        require(pauser == _msgSender() || owner() == _msgSender(), \"OwnablePausable::pause: only pauser and owner must pause contract\");\n        _pause();\n    }\n\n    /**\n     * @notice Returns to normal state.\n     */\n    function unpause() public virtual {\n        require(pauser == _msgSender() || owner() == _msgSender(), \"OwnablePausable::unpause: only pauser and owner must unpause contract\");\n        _unpause();\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/Vesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./utils/OwnablePausable.sol\";\n\ncontract Vesting is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice The number of periods for a per recipient.\n    function maxPeriodsPerRecipient() public pure returns (uint256) {\n        return 5;\n    } // 5 perios per recipient.\n\n    /// @notice Address of vesting token.\n    ERC20 public token;\n\n    struct Period {\n        // Identifier.\n        uint256 id;\n        // Reward amount.\n        uint256 amount;\n        // Unlockd date.\n        uint256 date;\n        // Description.\n        string description;\n        // Reward withdrawal flag.\n        bool withdrawal;\n    }\n\n    /// @dev Index last period.\n    uint256 internal currentPeriod = 0;\n\n    /// @dev Participants list.\n    EnumerableSet.AddressSet internal participants;\n\n    /// @dev All registered periods.\n    mapping(address => mapping(uint256 => Period)) internal periods;\n\n    /// @dev Period identifiers index.\n    mapping(address => uint256[]) internal periodsIndex;\n\n    /// @notice An event emitted when all votes delegate to.\n    event DelegateVotes(address delegatee);\n\n    /// @notice An event emitted when locking a period.\n    event Locked(uint256 periodId);\n\n    /// @notice An event emitted when revoked a period.\n    event Revoked(uint256 periodId);\n\n    /// @notice An event emitted when withdrawal a period.\n    event Withdrawal(address recipient, uint256 periodId);\n\n    /**\n     * @param _token Address of vesting token contract.\n     */\n    constructor(address _token) public {\n        token = ERC20(_token);\n    }\n\n    /**\n     * @notice Delegate votes to delegatee.\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address governanceToken, address delegatee) external onlyOwner {\n        GovernanceTokenInterface(governanceToken).delegate(delegatee);\n        emit DelegateVotes(delegatee);\n    }\n\n    /**\n     * @notice Add new period.\n     * @param recipient Recipient of reward.\n     * @param amount Reward amount.\n     * @param date Date of unlockd period.\n     * @return Added period identifier.\n     */\n    function lock(\n        address recipient,\n        uint256 amount,\n        string memory description,\n        uint256 date\n    ) external onlyOwner returns (uint256) {\n        require(periodsIndex[recipient].length <= maxPeriodsPerRecipient(), \"Vesting::lock: too many periods\");\n\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        currentPeriod += 1;\n        participants.add(recipient);\n        periods[recipient][currentPeriod] = Period(currentPeriod, amount, date, description, false);\n        periodsIndex[recipient].push(currentPeriod);\n        emit Locked(currentPeriod);\n\n        return currentPeriod;\n    }\n\n    /**\n     * @notice Revoke period.\n     * @param recipient Recipient of reward.\n     * @param periodId Period identifier.\n     */\n    function revoke(address recipient, uint256 periodId) external onlyOwner {\n        Period storage period = periods[recipient][periodId];\n        require(!period.withdrawal, \"Vesting::revoke: already withdraw\");\n\n        address owner = _msgSender();\n        uint256 amount = period.amount;\n        period.amount = 0;\n        token.safeTransfer(owner, amount);\n\n        emit Revoked(periodId);\n    }\n\n    /**\n     * @notice Return all participants addresses.\n     * @return Participants addresses.\n     */\n    function getParticipants() external view returns (address[] memory) {\n        address[] memory result = new address[](participants.length());\n\n        for (uint256 i = 0; i < participants.length(); i++) {\n            result[i] = participants.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Get information of period.\n     * @param recipient Recipient address.\n     * @return Recipient periods list.\n     */\n    function info(address recipient) external view returns (Period[] memory) {\n        Period[] memory result = new Period[](periodsIndex[recipient].length);\n\n        for (uint256 i = 0; i < periodsIndex[recipient].length; i++) {\n            uint256 periodId = periodsIndex[recipient][i];\n\n            result[i] = periods[recipient][periodId];\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Withdraw reward.\n     * @param periodId Target period identifier.\n     */\n    function withdraw(uint256 periodId) external whenNotPaused {\n        address recipient = _msgSender();\n        Period storage period = periods[recipient][periodId];\n        require(period.amount > 0, \"Vesting::withdraw: period is empty\");\n        require(!period.withdrawal, \"Vesting::withdraw: already withdraw\");\n        require(block.timestamp > period.date, \"Vesting::withdraw: access denied\");\n\n        period.withdrawal = true;\n        token.safeTransfer(recipient, period.amount);\n        emit Withdrawal(recipient, periodId);\n    }\n}\n\ninterface GovernanceTokenInterface {\n    function delegate(address delegatee) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/VestingSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./Vesting.sol\";\n\ncontract VestingSplitter is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @notice Vesting contract address.\n     */\n    address public vesting;\n\n    /**\n     * @notice Distributed tokens.\n     */\n    mapping(address => uint256) public totalSupply;\n\n    /**\n     * @dev Accounts balances.\n     */\n    mapping(address => mapping(address => uint256)) internal _balances;\n\n    /**\n     * @dev Accounts list.\n     */\n    EnumerableSet.AddressSet internal _accounts;\n\n    /**\n     * @dev Shares of account in split.\n     */\n    mapping(address => uint256) internal _share;\n\n    /// @notice An event emitted when vesting contract address changed.\n    event VestingChanged(address newVesting);\n\n    /// @notice An event emitted when shares changed.\n    event SharesChanged();\n\n    /// @notice An event emitted when vesting period withdrawal.\n    event VestingWithdraw(address vesting, uint256 periodId);\n\n    /// @notice An event emitted when split a balance.\n    event Split(address token);\n\n    /// @notice An event emitted when withdrawal a token.\n    event Withdraw(address token, address account, uint256 reward);\n\n    /**\n     * @param _vesting Vesting contract address.\n     */\n    constructor(address _vesting) public {\n        vesting = _vesting;\n    }\n\n    /**\n     * @notice Get accounts limit for split.\n     * @return Max accounts for split.\n     */\n    function getMaxAccounts() public pure returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @notice Get accounts with share list.\n     * @return Addresses of all accounts with share.\n     */\n    function getAccounts() public view returns (address[] memory) {\n        address[] memory result = new address[](_accounts.length());\n\n        for (uint256 i = 0; i < _accounts.length(); i++) {\n            result[i] = _accounts.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Get balance of account.\n     * @param token Target token.\n     * @param account Target account.\n     * @return Balance of account.\n     */\n    function balanceOf(address token, address account) public view returns (uint256) {\n        return _balances[token][account];\n    }\n\n    /**\n     * @notice Get share of account in split.\n     * @param account Target account.\n     * @return Share in split.\n     */\n    function shareOf(address account) public view returns (uint256) {\n        return _share[account];\n    }\n\n    /**\n     * @notice Change vesting contract address.\n     * @param _vesting New vesting contract address.\n     */\n    function changeVesting(address _vesting) external onlyOwner {\n        vesting = _vesting;\n        emit VestingChanged(vesting);\n    }\n\n    /**\n     * @notice Change shares of accounts in split.\n     * @param accounts Accounts list.\n     * @param shares Shares in split.\n     */\n    function changeShares(address[] memory accounts, uint256[] memory shares) external onlyOwner {\n        require(accounts.length <= getMaxAccounts(), \"VestingSplitter::changeShares: too many accounts\");\n        require(accounts.length == shares.length, \"VestingSplitter::changeShares: shares function information arity mismatch\");\n\n        // Reverse loop because the length of the set changes inside the loop condition\n        for (uint256 i = _accounts.length(); i > 0; i--) {\n            address account = _accounts.at(0);\n            _share[account] = 0;\n            _accounts.remove(account);\n        }\n\n        uint256 sharesSum;\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(!_accounts.contains(account), \"VestingSplitter::changeShares: duplicate account\");\n\n            uint256 share = shares[i];\n            require(share <= 100 && share > 0, \"VestingSplitter::changeShares: invalid value of share\");\n\n            _share[account] = share;\n            sharesSum = sharesSum.add(share);\n            _accounts.add(account);\n        }\n        require(sharesSum == 100, \"VestingSplitter::changeShares: invalid sum of shares\");\n        emit SharesChanged();\n    }\n\n    /**\n     * @notice Withdraw reward from vesting contract.\n     * @param periodId Target vesting period.\n     */\n    function vestingWithdraw(uint256 periodId) external {\n        Vesting(vesting).withdraw(periodId);\n        emit VestingWithdraw(vesting, periodId);\n    }\n\n    /**\n     * @notice Split token to all accounts.\n     * @param token Target token.\n     */\n    function split(address token) external {\n        uint256 balance = ERC20(token).balanceOf(address(this)).sub(totalSupply[token]);\n        require(balance > 0, \"VestingSplitter::split: empty balance\");\n\n        for (uint256 i = 0; i < _accounts.length(); i++) {\n            address account = _accounts.at(i);\n            uint256 share = _share[account];\n            uint256 reward = balance.mul(share).div(100);\n\n            _balances[token][account] = _balances[token][account].add(reward);\n            totalSupply[token] = totalSupply[token].add(reward);\n        }\n        emit Split(token);\n    }\n\n    /**\n     * @notice Withdraw token balance to sender.\n     * @param token Target token.\n     */\n    function withdraw(address token) external {\n        uint256 reward = _balances[token][_msgSender()];\n        _balances[token][_msgSender()] = 0;\n        totalSupply[token] = totalSupply[token].sub(reward);\n        ERC20(token).safeTransfer(_msgSender(), reward);\n        emit Withdraw(token, _msgSender(), reward);\n    }\n}\n"
    },
    "contracts/profit/ProfitSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\n\ncontract ProfitSplitter is OwnablePausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant SHARE_ACCURACY = 6;\n\n    uint256 public constant SHARE_DIGITS = 2;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Budget contract address.\n    address payable public budget;\n\n    /// @notice Target budget ETH balance.\n    uint256 public budgetBalance;\n\n    /// @notice Recipients share.\n    mapping(address => uint256) public shares;\n\n    /// @dev Recipients addresses index.\n    EnumerableSet.AddressSet private recipientsIndex;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an incoming token transferred to recipient.\n    event Transfer(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an budget contract address and target balance changed.\n    event BudgetChanged(address newBudget, uint256 newBalance);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an recipient added.\n    event RecipientAdded(address recipient, uint256 share);\n\n    /// @notice An event thats emitted when an recipient removed.\n    event RecipientRemoved(address recipient);\n\n    /// @notice An event thats emitted when an profit payed to budget.\n    event PayToBudget(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an profit payed to recipient.\n    event PayToRecipient(address recipient, uint256 amount);\n\n    receive() external payable {}\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(address _incoming, address _uniswapRouter) public {\n        incoming = ERC20(_incoming);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed budget contract address and target balance.\n     * @param _budget Address of budget contract.\n     * @param _budgetBalance Target budget balance.\n     */\n    function changeBudget(address payable _budget, uint256 _budgetBalance) external onlyOwner {\n        budget = _budget;\n        budgetBalance = _budgetBalance;\n        emit BudgetChanged(budget, budgetBalance);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param _recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(address _recipient, uint256 amount) public onlyOwner {\n        require(_recipient != address(0), \"ProfitSplitter::transfer: cannot transfer to the zero address\");\n\n        incoming.safeTransfer(_recipient, amount);\n        emit Transfer(_recipient, amount);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"ProfitSplitter::changeIncoming: duplicate incoming token address\");\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            transfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @dev Current share value.\n     * @return result Current share value.\n     */\n    function _currentShare() internal view returns (uint256 result) {\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            result = result.add(shares[recipientsIndex.at(i)]);\n        }\n    }\n\n    /**\n     * @notice Add recipient.\n     * @param recipient Address of recipient contract.\n     * @param share Target share.\n     */\n    function addRecipient(address recipient, uint256 share) external onlyOwner {\n        require(!recipientsIndex.contains(recipient), \"ProfitSplitter::addRecipient: recipient already added\");\n        require(share > 0 && _currentShare().add(share) <= 100, \"ProfitSplitter::addRecipient: invalid share\");\n\n        recipientsIndex.add(recipient);\n        shares[recipient] = share;\n        emit RecipientAdded(recipient, share);\n    }\n\n    /**\n     * @notice Remove recipient.\n     * @param recipient Address of recipient contract.\n     */\n    function removeRecipient(address recipient) external onlyOwner {\n        require(recipientsIndex.contains(recipient), \"ProfitSplitter::removeRecipient: recipient already removed\");\n\n        recipientsIndex.remove(recipient);\n        shares[recipient] = 0;\n        emit RecipientRemoved(recipient);\n    }\n\n    /**\n     * @notice Get addresses of recipients.\n     * @return Current recipients list.\n     */\n    function getRecipients() public view returns (address[] memory) {\n        address[] memory result = new address[](recipientsIndex.length());\n\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            result[i] = recipientsIndex.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Pay ETH to budget contract.\n     */\n    function _payToBudget() internal returns (bool) {\n        uint256 splitterIncomingBalance = incoming.balanceOf(address(this));\n        if (splitterIncomingBalance == 0) return false;\n\n        uint256 currentBudgetBalance = budget.balance;\n        if (currentBudgetBalance >= budgetBalance) return false;\n\n        uint256 amount = budgetBalance.sub(currentBudgetBalance);\n        uint256 splitterEthBalance = address(this).balance;\n        if (splitterEthBalance < amount) {\n            uint256 amountOut = amount.sub(splitterEthBalance);\n\n            address[] memory path = new address[](2);\n            path[0] = address(incoming);\n            path[1] = uniswapRouter.WETH();\n\n            uint256[] memory amountsIn = uniswapRouter.getAmountsIn(amountOut, path);\n            require(amountsIn.length == 2, \"ProfitSplitter::_payToBudget: invalid amounts in length\");\n            require(amountsIn[0] > 0, \"ProfitSplitter::_payToBudget: liquidity pool is empty\");\n            if (amountsIn[0] <= splitterIncomingBalance) {\n                incoming.safeApprove(address(uniswapRouter), 0);\n                incoming.safeApprove(address(uniswapRouter), amountsIn[0]);\n                uniswapRouter.swapTokensForExactETH(amountOut, amountsIn[0], path, address(this), block.timestamp);\n            } else {\n                uint256[] memory amountsOut = uniswapRouter.getAmountsOut(splitterIncomingBalance, path);\n                require(amountsOut.length == 2, \"ProfitSplitter::_payToBudget: invalid amounts out length\");\n                require(amountsOut[1] > 0, \"ProfitSplitter::_payToBudget: amounts out liquidity pool is empty\");\n\n                amount = splitterEthBalance.add(amountsOut[1]);\n\n                incoming.safeApprove(address(uniswapRouter), 0);\n                incoming.safeApprove(address(uniswapRouter), splitterIncomingBalance);\n                uniswapRouter.swapExactTokensForETH(splitterIncomingBalance, amountsOut[1], path, address(this), block.timestamp);\n            }\n        }\n\n        budget.transfer(amount);\n        emit PayToBudget(budget, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Pay incoming token to all recipients.\n     */\n    function _payToRecipients() internal returns (bool) {\n        uint256 splitterIncomingBalance = incoming.balanceOf(address(this));\n        if (splitterIncomingBalance == 0) return false;\n\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            address recipient = recipientsIndex.at(i);\n            uint256 share = shares[recipient];\n\n            uint256 amount = splitterIncomingBalance.mul(10**SHARE_ACCURACY).mul(share).div(10**SHARE_ACCURACY.add(SHARE_DIGITS));\n            incoming.safeTransfer(recipient, amount);\n\n            emit PayToRecipient(recipient, amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Split all incoming token balance to recipients and budget contract.\n     * @param amount Approved amount incoming token.\n     */\n    function split(uint256 amount) external whenNotPaused nonReentrant {\n        if (amount > 0) {\n            incoming.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n\n        _payToBudget();\n        _payToRecipients();\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/profit/UniswapMarketMaker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\nimport \"../uniswap/IUniswapV2Factory.sol\";\n\ncontract UniswapMarketMaker is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Support token.\n    ERC20 public support;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an token transferred to recipient.\n    event TokenTransfer(address token, address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an liquidity added.\n    event LiquidityIncreased(uint256 incoming, uint256 support);\n\n    /// @notice An event thats emitted when an liquidity removed.\n    event LiquidityReduced(uint256 lp, uint256 incoming, uint256 support);\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _support Address of support token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(\n        address _incoming,\n        address _support,\n        address _uniswapRouter\n    ) public {\n        incoming = ERC20(_incoming);\n        support = ERC20(_support);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param token Address of transferred token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        require(recipient != address(0), \"UniswapMarketMaker::transfer: cannot transfer to the zero address\");\n\n        ERC20(token).safeTransfer(recipient, amount);\n        emit TokenTransfer(token, recipient, amount);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"UniswapMarketMaker::changeIncoming: duplicate incoming token address\");\n\n        address pair = liquidityPair();\n        if (pair != address(0)) {\n            uint256 lpBalance = ERC20(pair).balanceOf(address(this));\n            if (lpBalance > 0) {\n                ERC20(pair).safeTransfer(_recipient, lpBalance);\n            }\n        }\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            incoming.safeTransfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @notice Buy support token and add liquidity.\n     * @param amount Amount of incoming token.\n     */\n    function buyLiquidity(uint256 amount) external whenNotPaused {\n        if (amount > 0) {\n            incoming.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(incoming);\n        path[1] = address(support);\n\n        uint256 amountIn = incoming.balanceOf(address(this)).div(2);\n        require(amountIn > 0, \"UniswapMarketMaker::buyLiquidity: not enough funds to buy back\");\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amountIn, path);\n        require(amountsOut.length != 0, \"UniswapMarketMaker::buyLiquidity: invalid amounts out length\");\n        uint256 amountOut = amountsOut[amountsOut.length - 1];\n        require(amountOut > 0, \"UniswapMarketMaker::buyLiquidity: liquidity pool is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), 0);\n        incoming.safeApprove(address(uniswapRouter), amountIn);\n        uniswapRouter.swapExactTokensForTokens(amountIn, amountOut, path, address(this), block.timestamp);\n\n        uint256 incomingBalance = incoming.balanceOf(address(this));\n        require(incomingBalance > 0, \"UniswapMarketMaker::buyLiquidity: incoming token balance is empty\");\n        uint256 supportBalance = support.balanceOf(address(this));\n        require(supportBalance > 0, \"UniswapMarketMaker::buyLiquidity: support token balance is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), 0);\n        incoming.safeApprove(address(uniswapRouter), incomingBalance);\n        support.safeApprove(address(uniswapRouter), 0);\n        support.safeApprove(address(uniswapRouter), supportBalance);\n        (uint256 amountA, uint256 amountB, ) = uniswapRouter.addLiquidity(address(incoming), address(support), incomingBalance, supportBalance, 0, 0, address(this), block.timestamp);\n        emit LiquidityIncreased(amountA, amountB);\n    }\n\n    /**\n     * @notice Add liquidity.\n     * @param incomingAmount Amount of incoming token.\n     * @param supportAmount Amount of support token.\n     */\n    function addLiquidity(uint256 incomingAmount, uint256 supportAmount) external whenNotPaused {\n        if (incomingAmount > 0) {\n            incoming.safeTransferFrom(_msgSender(), address(this), incomingAmount);\n        }\n        if (supportAmount > 0) {\n            support.safeTransferFrom(_msgSender(), address(this), supportAmount);\n        }\n\n        uint256 incomingBalance = incoming.balanceOf(address(this));\n        require(incomingBalance > 0, \"UniswapMarketMaker::addLiquidity: incoming token balance is empty\");\n        uint256 supportBalance = support.balanceOf(address(this));\n        require(supportBalance > 0, \"UniswapMarketMaker::addLiquidity: support token balance is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), 0);\n        incoming.safeApprove(address(uniswapRouter), incomingBalance);\n        support.safeApprove(address(uniswapRouter), 0);\n        support.safeApprove(address(uniswapRouter), supportBalance);\n        (uint256 amountA, uint256 amountB, ) = uniswapRouter.addLiquidity(address(incoming), address(support), incomingBalance, supportBalance, 0, 0, address(this), block.timestamp);\n        emit LiquidityIncreased(amountA, amountB);\n    }\n\n    /**\n     * @notice Return liquidity pair address.\n     * @return Liquidity pair address.\n     */\n    function liquidityPair() public view returns (address) {\n        IUniswapV2Factory uniswapFactory = IUniswapV2Factory(uniswapRouter.factory());\n        return uniswapFactory.getPair(address(incoming), address(support));\n    }\n\n    /**\n     * @notice Remove liquidity.\n     * @param amount Amount of liquidity pool token.\n     */\n    function removeLiquidity(uint256 amount) external onlyOwner {\n        address pair = liquidityPair();\n        require(pair != address(0), \"UniswapMarketMaker::removeLiquidity: liquidity pair not found\");\n\n        uint256 lpBalance = ERC20(pair).balanceOf(address(this));\n        amount = lpBalance < amount ? lpBalance : amount;\n        require(amount > 0, \"UniswapMarketMaker::removeLiquidity: zero amount\");\n\n        ERC20(pair).safeApprove(address(uniswapRouter), 0);\n        ERC20(pair).safeApprove(address(uniswapRouter), amount);\n        (uint256 incomingAmount, uint256 supportAmount) = uniswapRouter.removeLiquidity(address(incoming), address(support), amount, 0, 0, address(this), block.timestamp);\n        emit LiquidityReduced(amount, incomingAmount, supportAmount);\n    }\n}\n"
    },
    "contracts/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/waves/EastGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"../Market.sol\";\n\ncontract EastGateway is Context {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Address of market contract.\n    Market public market;\n\n    /// @notice Address of recipient all buy tokens.\n    address public recipient;\n\n    /// @notice An event thats emitted when an account buyed token.\n    event Buy(address indexed customer, address currency, uint256 sell, uint256 buy, uint256 reward);\n\n    constructor(address _market, address _recipient) public {\n        market = Market(_market);\n        recipient = _recipient;\n    }\n\n    function buy(ERC20 currency, uint256 amount, uint256 productMin) external returns (bool) {\n        currency.safeTransferFrom(_msgSender(), address(this), amount);\n\n        uint256 currencyBalance = currency.balanceOf(address(this));\n        if (currency.allowance(address(this), address(market)) != 0) {\n            currency.safeApprove(address(market), 0);\n        }\n        currency.safeApprove(address(market), currencyBalance);\n        market.buy(address(currency), currencyBalance, productMin);\n\n        ERC20 product = ERC20(market.productToken());\n        uint256 productBalance = product.balanceOf(address(this));\n        product.safeTransfer(recipient, productBalance);\n\n        ERC20 reward = ERC20(market.rewardToken());\n        uint256 rewardBalance = reward.balanceOf(address(this));\n        if (rewardBalance > 0) {\n            reward.safeTransfer(_msgSender(), rewardBalance);\n        }\n\n        emit Buy(_msgSender(), address(currency), currencyBalance, productBalance, rewardBalance);\n\n        return true;\n    }\n}\n"
    },
    "contracts/Market.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\n\ncontract Market is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Address of cumulative token.\n    ERC20 public cumulativeToken;\n\n    /// @notice Address of product token contract.\n    ERC20 public immutable productToken;\n\n    /// @notice Address of reward token contract.\n    ERC20 public immutable rewardToken;\n\n    /// @dev Address of UniswapV2Router.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address indexed newUniswapRouter);\n\n    /// @notice An event thats emitted when an cumulative token changed.\n    event CumulativeChanged(address indexed newCumulativeToken);\n\n    /// @notice An event thats emitted when an account buyed token.\n    event Buy(address indexed customer, address indexed currency, uint256 payment, uint256 buy, uint256 reward);\n\n    /**\n     * @param _cumulativeToken Address of cumulative token.\n     * @param _productToken Address of product token.\n     * @param _rewardToken Address of reward token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(\n        address _cumulativeToken,\n        address _productToken,\n        address _rewardToken,\n        address _uniswapRouter\n    ) public {\n        require(_cumulativeToken != _productToken && _cumulativeToken != _rewardToken, \"Market::constructor: invalid cumulative token address\");\n        require(_productToken != _rewardToken, \"Market::constructor: invalid product token address\");\n\n        cumulativeToken = ERC20(_cumulativeToken);\n        productToken = ERC20(_productToken);\n        rewardToken = ERC20(_rewardToken);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed cumulative token address.\n     * @param newCumulativeToken Address new cumulative token.\n     * @param recipient Address of recipient for withdraw current cumulative balance.\n     */\n    function changeCumulativeToken(address newCumulativeToken, address recipient) external onlyOwner {\n        require(newCumulativeToken != address(productToken) && newCumulativeToken != address(rewardToken), \"Market::changeCumulativeToken: invalid cumulative token address\");\n        require(cumulativeToken.decimals() <= productToken.decimals(), \"Market::changeCumulativeToken: invalid cumulative token decimals\");\n\n        transfer(address(cumulativeToken), recipient, cumulativeToken.balanceOf(address(this)));\n        cumulativeToken = ERC20(newCumulativeToken);\n        emit CumulativeChanged(newCumulativeToken);\n    }\n\n    /**\n     * @dev Transfer token to recipient.\n     * @param from Address of transfered token contract.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transfer(\n        address from,\n        address recipient,\n        uint256 amount\n    ) public onlyOwner {\n        require(recipient != address(0), \"Market::transfer: cannot transfer to the zero address\");\n\n        ERC20(from).safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @dev Calculate product and reward amount by cumulative token amount.\n     * @param amount Amount of cumulative token.\n     * @return product Amount of product token.\n     * @return reward Amount of reward token.\n     */\n    function _cumulativeToProduct(uint256 amount) internal view returns (uint256 product, uint256 reward) {\n        ERC20 _productToken = productToken; // gas optimization\n\n        product = amount.mul(10**uint256(_productToken.decimals()).sub(cumulativeToken.decimals()));\n\n        uint256 productTokenBalance = _productToken.balanceOf(address(this));\n        if (productTokenBalance > 0) {\n            reward = product.mul(rewardToken.balanceOf(address(this))).div(productTokenBalance);\n        }\n    }\n\n    /**\n     * @notice Get token price.\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return product Amount of product token.\n     * @return reward Amount of reward token.\n     */\n    function price(address currency, uint256 payment) public view returns (uint256 product, uint256 reward) {\n        address _cumulativeToken = address(cumulativeToken);\n        uint256 amountOut = payment;\n        if (currency != _cumulativeToken) {\n            address[] memory path = new address[](2);\n            path[0] = currency;\n            path[1] = _cumulativeToken;\n            uint256[] memory amountsOut = uniswapRouter.getAmountsOut(payment, path);\n            amountOut = amountsOut[1];\n        }\n\n        return _cumulativeToProduct(amountOut);\n    }\n\n    /**\n     * @notice Buy token with ERC20.\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @param productMin Minimum amount of output product token.\n     * @return True if success.\n     */\n    function buy(\n        address currency,\n        uint256 payment,\n        uint256 productMin\n    ) external whenNotPaused returns (bool) {\n        ERC20 _cumulativeToken = cumulativeToken; // gas optimization\n        ERC20 _productToken = productToken; // gas optimization\n        IUniswapV2Router02 _uniswapRouter = uniswapRouter; // gas optimization\n        address sender = _msgSender();\n\n        uint256 amountOut = payment;\n        ERC20(currency).safeTransferFrom(sender, address(this), payment);\n        if (currency != address(_cumulativeToken)) {\n            address[] memory path = new address[](2);\n            path[0] = currency;\n            path[1] = address(_cumulativeToken);\n            uint256 amountOutMin = productMin.div(10**uint256(_productToken.decimals()).sub(_cumulativeToken.decimals()));\n\n            ERC20(currency).safeApprove(address(_uniswapRouter), payment);\n            amountOut = _uniswapRouter.swapExactTokensForTokens(payment, amountOutMin, path, address(this), block.timestamp)[1];\n        }\n\n        (uint256 product, uint256 reward) = _cumulativeToProduct(amountOut);\n        _productToken.safeTransfer(sender, product);\n        if (reward > 0) {\n            rewardToken.safeTransfer(sender, reward);\n        }\n\n        emit Buy(sender, currency, payment, product, reward);\n\n        return true;\n    }\n}\n"
    },
    "contracts/YieldEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./VoteDelegator.sol\";\n\ncontract YieldEscrow is Ownable, ERC20 {\n    using SafeERC20 for ERC20;\n\n    /// @notice Governance token contract.\n    address public immutable governanceToken;\n\n    address public voteDelegatorPrototype;\n\n    /// @dev Created vote delegators by account.\n    mapping(address => address) internal _voteDelegators;\n\n    /// @dev Addresses that are allowed to transfer tokens.\n    mapping(address => bool) internal _allowedTransferAddresses;\n\n    event VoteDelegatorCreated(address indexed account, address voteDelegator);\n\n    event VoteDelegatorDestroyed(address indexed account);\n\n    event TransferAllowed(address indexed account);\n\n    event TransferDenied(address indexed account);\n\n    event Deposit(address indexed account, uint256 amount);\n\n    event Withdraw(address indexed account, uint256 amount);\n\n    /**\n     * @param _governanceToken Governance token contract address.\n     */\n    constructor(address _governanceToken, address _voteDelegatorPrototype) public ERC20(\"BondAppetit Governance yield\", \"yBAG\") {\n        governanceToken = _governanceToken;\n        voteDelegatorPrototype = _voteDelegatorPrototype;\n    }\n\n    /**\n     * @param account Target account.\n     * @return Address of vote delegator (zero if not delegate).\n     */\n    function voteDelegatorOf(address account) public view returns (address) {\n        return _voteDelegators[account];\n    }\n\n    /**\n     * @notice Create vote delegator contract for sender account.\n     * @return Address of vote delegator.\n     */\n    function createVoteDelegator() external returns (address) {\n        address account = _msgSender();\n        address accountVoteDelegator = voteDelegatorOf(account);\n        require(accountVoteDelegator == address(0), \"YieldEscrow::createVoteDelegator: votes delegator already created\");\n\n        bytes20 targetBytes = bytes20(voteDelegatorPrototype);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            accountVoteDelegator := create(0, clone, 0x37)\n        }\n        _voteDelegators[account] = accountVoteDelegator;\n        VoteDelegator(accountVoteDelegator).initialize(account);\n\n        uint256 accountBalance = balanceOf(account);\n        if (accountBalance > 0) {\n            ERC20(governanceToken).safeTransfer(accountVoteDelegator, accountBalance);\n        }\n        emit VoteDelegatorCreated(account, accountVoteDelegator);\n\n        return accountVoteDelegator;\n    }\n\n    /**\n     * @notice Allow transfer tokens for account.\n     * @param account Target account.\n     */\n    function allowTransfer(address account) external onlyOwner {\n        _allowedTransferAddresses[account] = true;\n        emit TransferAllowed(account);\n    }\n\n    /**\n     * @notice Deny transfer tokens for account.\n     * @param account Target account.\n     */\n    function denyTransfer(address account) external onlyOwner {\n        _allowedTransferAddresses[account] = false;\n        emit TransferDenied(account);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        // solhint-disable-next-line no-unused-vars\n        uint256 amount\n    ) internal override {\n        require(\n            _allowedTransferAddresses[from] ||\n                _allowedTransferAddresses[to] ||\n                from == address(0) || // mint\n                to == address(0), // burn\n            \"YieldEscrow: transfer of tokens is prohibited\"\n        );\n    }\n\n    /**\n     * @notice Deposit governance token.\n     * @param amount Deposit amount.\n     */\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"YieldEscrow::deposit: negative or zero amount\");\n        address account = _msgSender();\n        require(voteDelegatorOf(account) == address(0), \"YieldEscrow::deposit: vote delegator only deposit for this account\");\n\n        ERC20(governanceToken).safeTransferFrom(account, address(this), amount);\n        _mint(account, amount);\n        emit Deposit(account, amount);\n    }\n\n    /**\n     * @notice Deposit governance token from vote delegator only.\n     * @param account Target account.\n     * @param amount Deposit amount.\n     */\n    function depositFromDelegator(address account, uint256 amount) external {\n        require(amount > 0, \"YieldEscrow::depositFromDelegator: negative or zero amount\");\n        require(_msgSender() == voteDelegatorOf(account), \"YieldEscrow::depositFromDelegator: caller is not a vote delegator\");\n\n        _mint(account, amount);\n        emit Deposit(account, amount);\n    }\n\n    /**\n     * @notice Withdraw governance token.\n     * @param amount Withdraw amount.\n     */\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"YieldEscrow::withdraw: negative or zero amount\");\n        address account = _msgSender();\n        require(voteDelegatorOf(account) == address(0), \"YieldEscrow::withdraw: vote delegator only deposit for this account\");\n\n        _burn(account, amount);\n        ERC20(governanceToken).safeTransfer(account, amount);\n        emit Withdraw(account, amount);\n    }\n\n    /**\n     * @notice Withdraw governance token from vote delegator only.\n     * @param account Target account.\n     * @param amount Withdraw amount.\n     */\n    function withdrawFromDelegator(address account, uint256 amount) external {\n        require(amount > 0, \"YieldEscrow::withdrawFromDelegator: negative or zero amount\");\n        require(_msgSender() == voteDelegatorOf(account), \"YieldEscrow::withdrawFromDelegator: caller is not a vote delegator\");\n\n        _burn(account, amount);\n        emit Withdraw(account, amount);\n    }\n}\n"
    },
    "contracts/VoteDelegator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldEscrow.sol\";\nimport \"./GovernanceToken.sol\";\n\ncontract VoteDelegator {\n    /// @notice Contract owner.\n    address public owner;\n\n    /// @notice Yield escrow contract address.\n    address public yieldEscrow;\n\n    /// @notice Governance token contract address.\n    address public governanceToken;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @param _owner Owner account address.\n     */\n    function initialize(address _owner) external {\n        require(yieldEscrow == address(0), \"VoteDelegator::initialize: contract already initialized\");\n        yieldEscrow = msg.sender;\n        address _governanceToken = YieldEscrow(yieldEscrow).governanceToken(); // gas optimisation\n        governanceToken = _governanceToken;\n        GovernanceToken(_governanceToken).delegate(_owner);\n        owner = _owner;\n    }\n\n    /**\n     * @notice Deposit governance token.\n     * @param amount Deposit amount.\n     */\n    function deposit(uint256 amount) external onlyOwner {\n        address account = owner;\n        IERC20(governanceToken).transferFrom(account, address(this), amount);\n        YieldEscrow(yieldEscrow).depositFromDelegator(account, amount);\n    }\n\n    /**\n     * @notice Withdraw governance token.\n     * @param amount Withdraw amount.\n     */\n    function withdraw(uint256 amount) external onlyOwner {\n        address account = owner;\n        YieldEscrow(yieldEscrow).withdrawFromDelegator(account, amount);\n        IERC20(governanceToken).transfer(account, amount);\n    }\n}\n"
    },
    "contracts/GovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\ncontract GovernanceToken is IERC20, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice EIP-20 token name for this token\n    string public name = \"BondAppetit Governance\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public symbol = \"BAG\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    uint256 public override totalSupply = 100000000e18; // 100 million tokens\n\n    /// @dev Allowance amounts on behalf of others\n    mapping(address => mapping(address => uint96)) internal allowances;\n\n    /// @dev Official record of token balances for each account\n    mapping(address => uint96) internal balances;\n\n    /// @notice Amount of blocked token\n    struct Lock {\n        uint96 amount;\n        uint256 date;\n    }\n\n    /// @notice Locking amounts\n    mapping(address => Lock) public locking;\n\n    /// @dev Locking amounts\n    EnumerableSet.AddressSet internal lockingAllowed;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Construct a new token\n     * @param account The initial account to grant all the tokens\n     */\n    constructor(address account) public {\n        balances[account] = uint96(totalSupply);\n        emit Transfer(address(0), account, totalSupply);\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external override view returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 rawAmount) external override returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, \"GovernanceToken::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external override view returns (uint256) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 rawAmount) external override returns (bool) {\n        uint96 amount = safe96(rawAmount, \"GovernanceToken::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 rawAmount\n    ) external override returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"GovernanceToken::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"GovernanceToken::transferFrom: transfer amount exceeds spender allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Add account to transfer lock method allowed list\n     * @param account Allowable account\n     */\n    function allowTransferLock(address account) external onlyOwner returns (bool) {\n        return lockingAllowed.add(account);\n    }\n\n    /**\n     * @notice Remove account from transfer lock method allowed list\n     * @param account Denied account\n     */\n    function denyTransferLock(address account) external onlyOwner returns (bool) {\n        return lockingAllowed.remove(account);\n    }\n\n    function transferLock(address dst, uint256 rawAmount, uint256 date) external returns (bool) {\n        require(lockingAllowed.contains(msg.sender), \"GovernanceToken::transferLock: access is denied\");\n        require(locking[dst].date == 0 || locking[dst].date == date, \"GovernanceToken::transferLock: lock date cannot be changed\");\n        uint96 amount = safe96(rawAmount, \"GovernanceToken::transferLock: amount exceeds 96 bits\");\n\n        locking[dst].date = date;\n        locking[dst].amount = add96(locking[dst].amount, amount, \"GovernanceToken::transferLock: transfer amount overflows\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     * \n     * @param account Recipient of created token.\n     * @param amount Amount of token to be created.\n     */\n    function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }\n\n    /**\n     * @param account Owner of removed token.\n     * @param amount Amount of token to be removed.\n     */\n    function burn(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernanceToken::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"GovernanceToken::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"GovernanceToken::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"GovernanceToken::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(\n        address src,\n        address dst,\n        uint96 amount\n    ) internal {\n        require(src != address(0), \"GovernanceToken::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"GovernanceToken::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = sub96(balances[src], amount, \"GovernanceToken::_transferTokens: transfer amount exceeds balance\");\n        if (locking[src].date > block.timestamp && locking[src].amount > 0 && balances[src] < locking[src].amount) {\n            revert(\"GovernanceToken::_transferTokens: amount are locked\");\n        }\n        balances[dst] = add96(balances[dst], amount, \"GovernanceToken::_transferTokens: transfer amount overflows\");\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"GovernanceToken::_moveVotes: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"GovernanceToken::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(block.number, \"GovernanceToken::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 rawAmount) internal virtual {\n        require(account != address(0), \"GovernanceToken::_mint: mint to the zero address\");\n        uint96 amount = safe96(rawAmount, \"GovernanceToken::_mint: amount exceeds 96 bits\");\n\n        totalSupply = totalSupply.add(rawAmount);\n        balances[account] = add96(balances[account], amount, \"GovernanceToken::_mint: mint amount overflows\");\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 rawAmount) internal virtual {\n        require(account != address(0), \"GovernanceToken::_burn: burn from the zero address\");\n        uint96 amount = safe96(rawAmount, \"GovernanceToken::_burn: amount exceeds 96 bits\");\n\n        balances[account] = sub96(balances[account], amount, \"GovernanceToken::_burn: burn amount exceeds balance\");\n        totalSupply = totalSupply.sub(rawAmount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "contracts/profit/Buyback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\n\ncontract Buyback is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Outcoming token.\n    ERC20 public outcoming;\n\n    /// @notice Recipient address.\n    address public recipient;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an incoming token transferred to recipient.\n    event Transfer(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an recipient address changed.\n    event RecipientChanged(address newRecipient);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an buyback successed.\n    event BuybackSuccessed(uint256 incoming, uint256 outcoming);\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _outcoming Address of outcoming token.\n     * @param _recipient Address of recipient outcoming token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(\n        address _incoming,\n        address _outcoming,\n        address _recipient,\n        address _uniswapRouter\n    ) public {\n        incoming = ERC20(_incoming);\n        outcoming = ERC20(_outcoming);\n        recipient = _recipient;\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Change recipient address.\n     * @param _recipient New recipient address.\n     */\n    function changeRecipient(address _recipient) external onlyOwner {\n        recipient = _recipient;\n        emit RecipientChanged(recipient);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param _recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(address _recipient, uint256 amount) public onlyOwner {\n        require(_recipient != address(0), \"Buyback::transfer: cannot transfer to the zero address\");\n\n        incoming.safeTransfer(_recipient, amount);\n        emit Transfer(_recipient, amount);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"Buyback::changeIncoming: duplicate incoming token address\");\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            transfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @notice Make buyback attempt.\n     * @param amount Amount of tokens to buyback.\n     */\n    function buy(uint256 amount) external whenNotPaused {\n        if (amount > 0) {\n            incoming.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(incoming);\n        path[1] = address(outcoming);\n\n        uint256 amountIn = incoming.balanceOf(address(this));\n        require(amountIn > 0, \"Buyback::buy: incoming token balance is empty\");\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amountIn, path);\n        require(amountsOut.length != 0, \"Buyback::buy: invalid amounts out length\");\n        uint256 amountOut = amountsOut[amountsOut.length - 1];\n        require(amountOut > 0, \"Buyback::buy: liquidity pool is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), 0);\n        incoming.safeApprove(address(uniswapRouter), amountIn);\n        uniswapRouter.swapExactTokensForTokens(amountIn, amountOut, path, recipient, block.timestamp);\n        emit BuybackSuccessed(amountIn, amountOut);\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockERC20 is ERC20, Ownable {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) public ERC20(name, symbol) {\n        _mint(_msgSender(), initialSupply);\n    }\n\n    function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/Investment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\nimport \"./GovernanceToken.sol\";\n\ncontract Investment is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    ///@notice Address of cumulative token\n    ERC20 public cumulative;\n\n    ///@notice Address of governance token\n    GovernanceToken public governanceToken;\n\n    ///@notice Date of locking governance token\n    uint256 public governanceTokenLockDate;\n\n    uint8 internal constant GOVERNANCE_TOKEN_PRICE_DECIMALS = 6;\n\n    ///@notice Price governance token\n    uint256 public governanceTokenPrice;\n\n    ///@dev Address of UniswapV2Router\n    IUniswapV2Router02 internal uniswapRouter;\n\n    /// @dev Allowed tokens list.\n    EnumerableSet.AddressSet private _allowedTokens;\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an invest token allowed.\n    event InvestTokenAllowed(address token);\n\n    /// @notice An event thats emitted when an invest token denied.\n    event InvestTokenDenied(address token);\n\n    /// @notice An event thats emitted when an governance token price changed.\n    event GovernanceTokenPriceChanged(uint256 newPrice);\n\n    /// @notice An event thats emitted when an governance token lock date changed.\n    event GovernanceTokenLockDateChanged(uint256 newLockDate);\n\n    /// @notice An event thats emitted when an invested token.\n    event Invested(address investor, address token, uint256 amount, uint256 reward);\n\n    /// @notice An event thats emitted when an withdrawal token.\n    event Withdrawal(address recipient, address token, uint256 amount);\n\n    /**\n     * @param _cumulative Address of cumulative token\n     * @param _governanceToken Address of governance token\n     * @param _governanceTokenLockDate Lock date of governance token\n     * @param _governanceTokenPrice Governance token price\n     * @param _uniswapRouter Address of UniswapV2Router\n     */\n    constructor(\n        address _cumulative,\n        address _governanceToken,\n        uint256 _governanceTokenLockDate,\n        uint256 _governanceTokenPrice,\n        address _uniswapRouter\n    ) public {\n        cumulative = ERC20(_cumulative);\n        governanceToken = GovernanceToken(_governanceToken);\n        governanceTokenLockDate = _governanceTokenLockDate;\n        governanceTokenPrice = _governanceTokenPrice;\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Add token to investable tokens white list\n     * @param token Allowable token\n     */\n    function allowToken(address token) external onlyOwner {\n        _allowedTokens.add(token);\n        emit InvestTokenAllowed(token);\n    }\n\n    /**\n     * @notice Remove token from investable tokens white list\n     * @param token Denied token\n     */\n    function denyToken(address token) external onlyOwner {\n        _allowedTokens.remove(token);\n        emit InvestTokenDenied(token);\n    }\n\n    /**\n     * @return Allowed tokens list.\n     */\n    function allowedTokens() external view returns (address[] memory) {\n        address[] memory result = new address[](_allowedTokens.length());\n\n        for (uint256 i = 0; i < _allowedTokens.length(); i++) {\n            result[i] = _allowedTokens.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Update governance token price\n     * @param newPrice New price of governance token of USD (6 decimal)\n     */\n    function changeGovernanceTokenPrice(uint256 newPrice) external onlyOwner {\n        require(newPrice > 0, \"Investment::changeGovernanceTokenPrice: invalid new governance token price\");\n\n        governanceTokenPrice = newPrice;\n        emit GovernanceTokenPriceChanged(newPrice);\n    }\n\n    /**\n     * @notice Update governance token lock date.\n     * @param _governanceTokenLockDate New lock date of governance token.\n     */\n    function changeGovernanceTokenLockDate(uint256 _governanceTokenLockDate) external onlyOwner {\n        governanceTokenLockDate = _governanceTokenLockDate;\n        emit GovernanceTokenLockDateChanged(governanceTokenLockDate);\n    }\n\n    /**\n     * @param token Invested token\n     * @return Pools for each consecutive pair of addresses must exist and have liquidity\n     */\n    function _path(address token) internal view returns (address[] memory) {\n        address weth = uniswapRouter.WETH();\n        if (weth == token) {\n            address[] memory path = new address[](2);\n            path[0] = token;\n            path[1] = address(cumulative);\n            return path;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = token;\n        path[1] = weth;\n        path[2] = address(cumulative);\n        return path;\n    }\n\n    /**\n     * @param token Invested token\n     * @param amount Invested amount\n     * @return Amount cumulative token after swap\n     */\n    function _amountOut(address token, uint256 amount) internal view returns (uint256) {\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amount, _path(token));\n        require(amountsOut.length != 0, \"Investment::_amountOut: invalid amounts out length\");\n\n        return amountsOut[amountsOut.length - 1];\n    }\n\n    /**\n     * @param amount Cumulative amount invested\n     * @return Amount governance token after swap\n     */\n    function _governanceTokenPrice(uint256 amount) internal view returns (uint256) {\n        uint256 decimals = cumulative.decimals();\n\n        return amount.mul(10**(uint256(18).sub(decimals).add(GOVERNANCE_TOKEN_PRICE_DECIMALS))).div(governanceTokenPrice);\n    }\n\n    /**\n     * @param token Invested token\n     * @param amount Invested amount\n     * @return Amount governance token after swap\n     */\n    function price(address token, uint256 amount) external view returns (uint256) {\n        require(_allowedTokens.contains(token), \"Investment::price: invalid investable token\");\n\n        uint256 amountOut = amount;\n        if (token != address(cumulative)) {\n            amountOut = _amountOut(token, amount);\n        }\n\n        return _governanceTokenPrice(amountOut);\n    }\n\n    /**\n     * @notice Invest tokens to protocol\n     * @param token Invested token\n     * @param amount Invested amount\n     */\n    function invest(address token, uint256 amount) external whenNotPaused returns (bool) {\n        require(_allowedTokens.contains(token), \"Investment::invest: invalid investable token\");\n        uint256 reward = _governanceTokenPrice(amount);\n\n        ERC20(token).safeTransferFrom(_msgSender(), address(this), amount);\n\n        if (token != address(cumulative)) {\n            uint256 amountOut = _amountOut(token, amount);\n            require(amountOut != 0, \"Investment::invest: liquidity pool is empty\");\n            reward = _governanceTokenPrice(amountOut);\n\n            ERC20(token).safeApprove(address(uniswapRouter), 0);\n            ERC20(token).safeApprove(address(uniswapRouter), amount);\n            uniswapRouter.swapExactTokensForTokens(amount, amountOut, _path(token), address(this), block.timestamp);\n        }\n\n        governanceToken.transferLock(_msgSender(), reward, governanceTokenLockDate);\n\n        emit Invested(_msgSender(), token, amount, reward);\n        return true;\n    }\n\n    /**\n     * @notice Invest ETH to protocol\n     */\n    function investETH() external payable whenNotPaused returns (bool) {\n        address token = uniswapRouter.WETH();\n        require(_allowedTokens.contains(token), \"Investment::investETH: invalid investable token\");\n        uint256 reward = _governanceTokenPrice(msg.value);\n\n        if (token != address(cumulative)) {\n            uint256 amountOut = _amountOut(token, msg.value);\n            require(amountOut != 0, \"Investment::invest: liquidity pool is empty\");\n            reward = _governanceTokenPrice(amountOut);\n\n            uniswapRouter.swapExactETHForTokens{value: msg.value}(amountOut, _path(token), address(this), block.timestamp);\n        }\n\n        governanceToken.transferLock(_msgSender(), reward, governanceTokenLockDate);\n\n        emit Invested(_msgSender(), token, msg.value, reward);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw invested token to address\n     * @param recipient Recipient of tokens\n     */\n    function withdraw(address recipient) external onlyOwner {\n        require(recipient != address(0), \"Investment::withdraw: cannot transfer to the zero address\");\n\n        uint256 balance = cumulative.balanceOf(address(this));\n        cumulative.safeTransfer(recipient, balance);\n\n        emit Withdrawal(recipient, address(cumulative), balance);\n    }\n}\n"
    },
    "contracts/depositary/StableTokenDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./IDepositaryBalanceView.sol\";\n\ncontract StableTokenDepositaryBalanceView is Ownable, IDepositaryBalanceView {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Balance decimals.\n    uint256 public override decimals = 18;\n\n    /// @dev Allowed tokens.\n    EnumerableSet.AddressSet private tokens;\n\n    /// @notice An event emitted when token allowed.\n    event TokenAllowed(address token);\n\n    /// @notice An event emitted when token denied.\n    event TokenDenied(address token);\n\n    /**\n     * @notice Allow token.\n     * @param token Allowed token.\n     */\n    function allowToken(address token) external onlyOwner {\n        require(!tokens.contains(token), \"TokenDepositary::allowToken: token already allowed\");\n\n        uint256 tokenDecimals = ERC20(token).decimals();\n        require(tokenDecimals <= decimals, \"TokenDepositary::allowToken: invalid token decimals\");\n\n        tokens.add(token);\n        emit TokenAllowed(token);\n    }\n\n    /**\n     * @notice Deny token.\n     * @param token Denied token.\n     */\n    function denyToken(address token) external onlyOwner {\n        require(tokens.contains(token), \"TokenDepositary::denyToken: token already denied\");\n\n        tokens.remove(token);\n        emit TokenDenied(token);\n    }\n\n    /**\n     * @notice Transfer target token to recipient.\n     * @param token Target token.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transfer(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        ERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @return Allowed tokens list.\n     */\n    function allowedTokens() external view returns (address[] memory) {\n        address[] memory result = new address[](tokens.length());\n\n        for(uint256 i = 0; i < tokens.length(); i++) {\n            result[i] = tokens.at(i);\n        }\n\n        return result;\n    }\n\n    function balance() external override view returns (uint256) {\n        uint256 result;\n\n        for(uint256 i = 0; i < tokens.length(); i++) {\n            ERC20 token = ERC20(tokens.at(i));\n            uint256 tokenBalance = token.balanceOf(address(this));\n            uint256 tokenDecimals = token.decimals();\n\n            result = result.add(tokenBalance.mul(10**(decimals.sub(tokenDecimals))));\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/depositary/UniV2BuybackDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"./IDepositaryBalanceView.sol\";\nimport \"../Issuer.sol\";\n\ncontract UniV2BuybackDepositaryBalanceView is IDepositaryBalanceView, OwnablePausable {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Balance decimals.\n    uint256 public constant override decimals = 18;\n\n    /// @notice Address of buyback token.\n    ERC20 public immutable token;\n\n    /// @notice Address of issuer contract.\n    Issuer public issuer;\n\n    /// @notice Uniswap router contract.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice Buyback caller.\n    address public caller;\n\n    /// @notice An event that is emitted when an issuer contract address changed.\n    event IssuerChanged(address newIssuer);\n\n    /// @notice An event that is emitted when an Uniswap router contract address changed.\n    event UniswapRouterChanged(address newRouter);\n\n    /// @notice An event that is emitted when an caller wallet changed.\n    event CallerChanged(address newCaller);\n\n    /// @notice An event that is emitted when an contract buyback stable token.\n    event Buyback(uint256 amount, uint256 buy);\n\n    constructor(\n        address _token,\n        address _issuer,\n        address _uniswapRouter,\n        address _caller\n    ) public {\n        token = ERC20(_token);\n        issuer = Issuer(_issuer);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        caller = _caller;\n    }\n\n    /**\n     * @notice Change issuer contract address.\n     * @param _issuer New issuer contract address.\n     */\n    function changeIssuer(address _issuer) external onlyOwner {\n        require(_issuer != address(0), \"UniV2BuybackDepositaryBalanceView::changeIssuer: invalid address\");\n        issuer = Issuer(_issuer);\n\n        require(issuer.stableToken().decimals() >= ERC20(token).decimals(), \"UniV2BuybackDepositaryBalanceView::changeIssuer: invalid stable token decimals\");\n\n        emit IssuerChanged(_issuer);\n    }\n\n    /**\n     * @notice Change Uniswap router contract address.\n     * @param _uniswapRouter New Uniswap router contract address.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        require(_uniswapRouter != address(0), \"UniV2BuybackDepositaryBalanceView::changeUniswapRouter: invalid address\");\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Change caller wallet.\n     * @param _caller New caller wallet.\n     */\n    function changeCaller(address _caller) external onlyOwner {\n        caller = _caller;\n        emit CallerChanged(_caller);\n    }\n\n    /**\n     * @notice Transfer token to recipient.\n     * @param _token Target token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(\n        address _token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        ERC20(_token).safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Buyback stable token from Uniswap pool.\n     * @param amount Amount of buyback token.\n     */\n    function buy(uint256 amount) external whenNotPaused {\n        require(_msgSender() == owner() || _msgSender() == caller, \"UniV2BuybackDepositaryBalanceView::buy: invalid caller\");\n        require(amount > 0, \"UniV2BuybackDepositaryBalanceView::buy: zero amount\");\n\n        address stableToken = address(issuer.stableToken());\n        uint256 stableTokenDecimals = ERC20(stableToken).decimals();\n\n        uint256 allowance = token.allowance(address(this), address(uniswapRouter));\n        if (allowance < amount) {\n            if (allowance > 0) {\n                token.approve(address(uniswapRouter), 0);\n            }\n            token.approve(address(uniswapRouter), amount);\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(token);\n        path[1] = stableToken;\n        uint256[] memory amounts = uniswapRouter.swapExactTokensForTokens(\n            amount,\n            amount.mul(10**(stableTokenDecimals.sub(token.decimals()))), // 1 to 1\n            path,\n            address(this),\n            block.timestamp + 10 minutes\n        );\n\n        uint256 stableTotalSupply = ERC20(stableToken).totalSupply();\n        uint256 collateralBalance = issuer.balance();\n        if (stableTotalSupply > collateralBalance) {\n            uint256 issuerInbalance = stableTotalSupply.sub(collateralBalance);\n            uint256 burningAmount = issuerInbalance.min(ERC20(stableToken).balanceOf(address(this)));\n            if (burningAmount > 0) {\n                ERC20(stableToken).safeTransfer(address(issuer), burningAmount);\n                issuer.rebalance();\n            }\n        }\n        emit Buyback(amount, amounts[1]);\n    }\n\n    /**\n     * @notice Get balance of depositary.\n     * @return Balance of depositary.\n     */\n    function balance() external view override returns (uint256) {\n        uint256 tokenBalance = token.balanceOf(address(this));\n\n        return tokenBalance.mul(10**(decimals.sub(token.decimals())));\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/Issuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./depositary/AgregateDepositaryBalanceView.sol\";\nimport \"./StableToken.sol\";\n\ncontract Issuer is AgregateDepositaryBalanceView {\n    using Math for uint256;\n    using SafeMath for uint256;\n\n    /// @notice Stable token contract address.\n    StableToken public stableToken;\n\n    /// @notice Treasury contract address.\n    address public treasury;\n\n    /// @notice An event thats emitted when an Treasury contract transfered.\n    event TransferTreasury(address newTreasury);\n\n    /// @notice An event thats emitted when an stable token total supply rebalanced.\n    event Rebalance();\n\n    /**\n     * @param _stableToken Stable token contract address.\n     * @param _treasury Treasury contract address.\n     */\n    constructor(address _stableToken, address _treasury) public AgregateDepositaryBalanceView(StableToken(_stableToken).decimals(), 50) {\n        stableToken = StableToken(_stableToken);\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Transfer Treasury contract to new address.\n     * @param _treasury New address Treasury contract.\n     */\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n        emit TransferTreasury(treasury);\n    }\n\n    /**\n     * @notice Change owner of Stable token contract.\n     * @param _owner New owner address.\n     */\n    function changeStableTokenOwner(address _owner) external onlyOwner {\n        stableToken.transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Rebalance stable token total supply by depositary balance. Mint stable token if depositary balance greater token total supply and burn otherwise.\n     */\n    function rebalance() external whenNotPaused {\n        uint256 currentDepositaryBalance = this.balance();\n        uint256 stableTokenTotalSupply = stableToken.totalSupply();\n\n        if (stableTokenTotalSupply > currentDepositaryBalance) {\n            uint256 burningBalance = stableToken.balanceOf(address(this));\n\n            if (burningBalance > 0) {\n                stableToken.burn(address(this), burningBalance.min(stableTokenTotalSupply.sub(currentDepositaryBalance)));\n                emit Rebalance();\n            }\n        } else if (stableTokenTotalSupply < currentDepositaryBalance) {\n            stableToken.mint(treasury, currentDepositaryBalance.sub(stableTokenTotalSupply));\n            emit Rebalance();\n        }\n    }\n}\n"
    },
    "contracts/depositary/AgregateDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"./IDepositaryBalanceView.sol\";\n\ncontract AgregateDepositaryBalanceView is IDepositaryBalanceView, OwnablePausable {\n    using SafeMath for uint256;\n\n    /// @notice The number of depositaries in agregate.\n    uint256 public maxSize;\n\n    /// @notice Decimals balance.\n    uint256 public override decimals;\n\n    /// @notice Depositaries in agregate.\n    IDepositaryBalanceView[] public depositaries;\n\n    /// @dev Depositaries index.\n    mapping(address => uint256) internal depositariesIndex;\n\n    /// @notice An event thats emitted when an new depositary added to agregate.\n    event DepositaryAdded(address depositary);\n\n    /// @notice An event thats emitted when an depositary removed from agregate.\n    event DepositaryRemoved(address depositary);\n\n    /**\n     * @param _decimals Decimals balance.\n     * @param _maxSize Max number depositaries in agregate.\n     */\n    constructor(uint256 _decimals, uint256 _maxSize) public {\n        decimals = _decimals;\n        maxSize = _maxSize;\n    }\n\n    /**\n     * @return Depositaries count of agregate.\n     */\n    function size() public view returns (uint256) {\n        return depositaries.length;\n    }\n\n    /**\n     * @notice Add depositary address to agregate.\n     * @param depositary Added depositary address.\n     */\n    function addDepositary(address depositary) external onlyOwner {\n        require(depositariesIndex[depositary] == 0, \"AgregateDepositaryBalanceView::addDepositary: depositary already added\");\n        require(size() < maxSize, \"AgregateDepositaryBalanceView::addDepositary: too many depositaries\");\n\n        depositaries.push(IDepositaryBalanceView(depositary));\n        depositariesIndex[depositary] = size();\n        emit DepositaryAdded(depositary);\n    }\n\n    /**\n     * @notice Removed depositary address from agregate.\n     * @param depositary Removed depositary address.\n     */\n    function removeDepositary(address depositary) external onlyOwner {\n        uint256 valueIndex = depositariesIndex[depositary];\n        require(valueIndex != 0, \"AgregateDepositaryBalanceView::removeDepositary: depositary already removed\");\n\n        uint256 toDeleteIndex = valueIndex.sub(1);\n        uint256 lastIndex = size().sub(1);\n        IDepositaryBalanceView lastValue = depositaries[lastIndex];\n        depositaries[toDeleteIndex] = lastValue;\n        depositariesIndex[address(lastValue)] = toDeleteIndex.add(1);\n        depositaries.pop();\n        delete depositariesIndex[depositary];\n\n        emit DepositaryRemoved(depositary);\n    }\n\n    /**\n     * @param depositary Target depositary address.\n     * @return True if target depositary is allowed.\n     */\n    function hasDepositary(address depositary) external view returns (bool) {\n        return depositariesIndex[depositary] != 0;\n    }\n\n    /**\n     * @return Allowed depositaries list.\n     */\n    function allowedDepositaries() external view returns (address[] memory) {\n        address[] memory result = new address[](size());\n\n        for (uint256 i = 0; i < size(); i++) {\n            result[i] = address(depositaries[i]);\n        }\n\n        return result;\n    }\n\n    function balance() external view override returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < size(); i++) {\n            uint256 depositaryBalance = depositaries[i].balance();\n            uint256 depositaryDecimals = depositaries[i].decimals();\n            uint256 decimalsPower = decimals.sub(depositaryDecimals);\n            result = result.add(depositaryBalance.mul(10**decimalsPower));\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/StableToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./utils/AccessControl.sol\";\n\ncontract StableToken is ERC20, AccessControl {\n    /**\n     * @param initialSupply Total supply.\n     */\n    constructor(uint256 initialSupply) public ERC20(\"Bond Appetite USD\", \"USDap\") {\n        _mint(_msgSender(), initialSupply);\n    }\n\n    /**\n     * @param account Recipient of created token.\n     * @param amount Amount of token to be created.\n     */\n    function mint(address account, uint256 amount) public onlyAllowed {\n        _mint(account, amount);\n    }\n\n    /**\n     * @param account Owner of removed token.\n     * @param amount Amount of token to be removed.\n     */\n    function burn(address account, uint256 amount) public onlyAllowed {\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\ncontract AccessControl is Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Allowed address list.\n    EnumerableSet.AddressSet private allowed;\n\n    /// @notice An event emitted when address allowed.\n    event AccessAllowed(address member);\n\n    /// @notice An event emitted when address denied.\n    event AccessDenied(address member);\n\n    /**\n     * @notice Allow access.\n     * @param member Target address.\n     */\n    function allowAccess(address member) external onlyOwner {\n        require(!allowed.contains(member), \"AccessControl::allowAccess: member already allowed\");\n\n        allowed.add(member);\n        emit AccessAllowed(member);\n    }\n\n    /**\n     * @notice Deny access.\n     * @param member Target address.\n     */\n    function denyAccess(address member) external onlyOwner {\n        require(allowed.contains(member), \"AccessControl::denyAccess: member already denied\");\n\n        allowed.remove(member);\n        emit AccessDenied(member);\n    }\n\n    /**\n     * @return Allowed address list.\n     */\n    function accessList() external view returns (address[] memory) {\n        address[] memory result = new address[](allowed.length());\n\n        for (uint256 i = 0; i < allowed.length(); i++) {\n            result[i] = allowed.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Throws if called by any account other than allowed.\n     */\n    modifier onlyAllowed() {\n        require(allowed.contains(_msgSender()) || _msgSender() == owner(), \"AccessControl: caller is not allowed\");\n        _;\n    }\n}\n"
    },
    "contracts/depositary/BuybackDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"./IDepositaryBalanceView.sol\";\nimport \"../Issuer.sol\";\n\ncontract BuybackDepositaryBalanceView is IDepositaryBalanceView, OwnablePausable {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Balance decimals.\n    uint256 public override constant decimals = 18;\n\n    /// @notice Address of product token.\n    ERC20 public immutable product;\n\n    /// @notice Address of issuer contract.\n    Issuer public issuer;\n\n    /// @notice An event that is emitted when an issuer contract address changed.\n    event IssuerChanged(address newIssuer);\n\n    /// @notice An event that is emitted when an account buyback stable token.\n    event Buyback(address indexed customer, uint256 amount, uint256 buy);\n\n    /**\n     * @param _issuer Issuer contract address.\n     * @param _product Product token address.\n     */\n    constructor(address _issuer, address _product) public {\n        require(ERC20(_product).decimals() <= decimals, \"BuybackDepositaryBalanceView::constructor: invalid decimals of product token\");\n\n        issuer = Issuer(_issuer);\n        product = ERC20(_product);\n    }\n\n    /**\n     * @notice Change issuer contract address.\n     * @param _issuer New issuer contract address.\n     */\n    function changeIssuer(address _issuer) external onlyOwner {\n        require(_issuer != address(0), \"BuybackDepositaryBalanceView::changeIssuer: invalid issuer address\");\n\n        issuer = Issuer(_issuer);\n        emit IssuerChanged(_issuer);\n    }\n\n    /**\n     * @dev Transfer token to recipient.\n     * @param token Transferred token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function _transfer(\n        ERC20 token,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(recipient != address(0), \"BuybackDepositaryBalanceView::_transfer: cannot transfer to the zero address\");\n\n        token.safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Transfer product token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transferProductToken(address recipient, uint256 amount) external onlyOwner {\n        _transfer(product, recipient, amount);\n    }\n\n    /**\n     * @notice Transfer stable token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transferStableToken(address recipient, uint256 amount) external onlyOwner {\n        _transfer(ERC20(issuer.stableToken()), recipient, amount);\n    }\n\n    /**\n     * @notice Buyback stable token.\n     * @param amount Amount of payment token.\n     */\n    function buy(uint256 amount) external whenNotPaused {\n        uint256 productAmount = amount.div(10**(decimals.sub(product.decimals())));\n        require(productAmount > 0, \"BuybackDepositaryBalanceView::buy: invalid product amount\");\n        require(productAmount <= product.balanceOf(address(this)), \"BuybackDepositaryBalanceView::buy: product amount exceeds balance\");\n\n        ERC20 stableToken = ERC20(issuer.stableToken());\n        stableToken.safeTransferFrom(_msgSender(), address(this), amount);\n        product.safeTransfer(_msgSender(), productAmount);\n\n        uint256 stableTotalSupply = stableToken.totalSupply();\n        uint256 collateralBalance = issuer.balance();\n        if (stableTotalSupply > collateralBalance) {\n            uint256 issuerInbalance = stableTotalSupply.sub(collateralBalance);\n            uint256 burningAmount = issuerInbalance.min(stableToken.balanceOf(address(this)));\n            if (burningAmount > 0) {\n                stableToken.safeTransfer(address(issuer), burningAmount);\n                issuer.rebalance();\n            }\n        }\n\n        emit Buyback(_msgSender(), amount, productAmount);\n    }\n\n    function balance() external view override returns (uint256) {\n        uint256 productBalance = product.balanceOf(address(this));\n\n        return productBalance.mul(10**(decimals.sub(product.decimals())));\n    }\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./utils/OwnablePausable.sol\";\n\ncontract Staking is OwnablePausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of rewards distributor.\n    address public rewardsDistribution;\n\n    /// @notice Rewards token address.\n    IERC20 public rewardsToken;\n\n    /// @notice Staking token address.\n    IERC20 public stakingToken;\n\n    /// @notice Block number of rewards distibution period finish.\n    uint256 public periodFinish;\n\n    /// @notice Reward distribution amount per block.\n    uint256 public rewardRate;\n\n    /// @notice Blocks count in current distribution period.\n    uint256 public rewardsDuration;\n\n    /// @notice Block number of last update.\n    uint256 public lastUpdateBlock;\n\n    /// @notice Static reward distribution amount per block.\n    uint256 public rewardPerTokenStored;\n\n    /// @notice Staking completion block number.\n    uint256 public stakingEndBlock;\n\n    /// @notice Unstaking start block number.\n    uint256 public unstakingStartBlock;\n\n    /// @notice Rewards paid.\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    /// @notice Earned rewards.\n    mapping(address => uint256) public rewards;\n\n    /// @dev Total staking token amount.\n    uint256 internal _totalSupply;\n\n    /// @dev Staking balances.\n    mapping(address => uint256) internal _balances;\n\n    /// @notice An event thats emitted when an reward token addet to contract.\n    event RewardAdded(uint256 reward);\n\n    /// @notice An event thats emitted when an staking token added to contract.\n    event Staked(address indexed user, uint256 amount);\n\n    /// @notice An event thats emitted when an staking token withdrawal from contract.\n    event Withdrawn(address indexed user, uint256 amount);\n\n    /// @notice An event thats emitted when an reward token withdrawal from contract.\n    event RewardPaid(address indexed user, uint256 reward);\n\n    /// @notice An event thats emitted when an rewards distribution address changed.\n    event RewardsDistributionChanged(address newRewardsDistribution);\n\n    /// @notice An event thats emitted when an rewards tokens transfered to recipient.\n    event RewardsTransfered(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an staking end block number changed.\n    event StakingEndBlockChanged(uint256 newBlockNumber);\n\n    /// @notice An event thats emitted when an unstaking start block number changed.\n    event UnstakingStartBlockChanged(uint256 newBlockNumber);\n\n    /**\n     * @param _rewardsDistribution Rewards distribution address.\n     * @param _rewardsDuration Duration of distribution.\n     * @param _rewardsToken Address of reward token.\n     * @param _stakingToken Address of staking token.\n     */\n    constructor(\n        address _rewardsDistribution,\n        uint256 _rewardsDuration,\n        address _rewardsToken,\n        address _stakingToken,\n        uint256 _stakingEndBlock,\n        uint256 _unstakingStartBlock\n    ) public {\n        rewardsDistribution = _rewardsDistribution;\n        rewardsDuration = _rewardsDuration;\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        stakingEndBlock = _stakingEndBlock;\n        unstakingStartBlock = _unstakingStartBlock;\n    }\n\n    /**\n     * @notice Update target account rewards state.\n     * @param account Target account.\n     */\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateBlock = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /**\n     * @return Total staking token amount.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @param account Target account.\n     * @return Staking token amount.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @return Block number of last reward.\n     */\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.number, periodFinish);\n    }\n\n    /**\n     * @return Reward per token.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateBlock).mul(rewardRate).mul(1e18).div(_totalSupply));\n    }\n\n    /**\n     * @param account Target account.\n     * @return Earned rewards.\n     */\n    function earned(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }\n\n    /**\n     * @return Rewards amount for duration.\n     */\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    /**\n     * @notice Stake token.\n     * @param amount Amount staking token.\n     */\n    function stake(uint256 amount) external nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"Staking::stake: cannot stake 0\");\n        if (stakingEndBlock > 0) {\n            require(block.number < stakingEndBlock, \"Staking:stake: staking completed\");\n        }\n        _totalSupply = _totalSupply.add(amount);\n        _balances[_msgSender()] = _balances[_msgSender()].add(amount);\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit Staked(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Withdraw staking token.\n     * @param amount Amount withdraw token.\n     */\n    function withdraw(uint256 amount) public nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"Staking::withdraw: Cannot withdraw 0\");\n        require(block.number >= unstakingStartBlock, \"Staking:withdraw: unstaking not started\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[_msgSender()] = _balances[_msgSender()].sub(amount);\n        stakingToken.safeTransfer(_msgSender(), amount);\n        emit Withdrawn(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Withdraw reward token.\n     */\n    function getReward() public nonReentrant updateReward(_msgSender()) {\n        uint256 reward = rewards[_msgSender()];\n        if (reward > 0) {\n            rewards[_msgSender()] = 0;\n            rewardsToken.safeTransfer(_msgSender(), reward);\n            emit RewardPaid(_msgSender(), reward);\n        }\n    }\n\n    /**\n     * @notice Withdraw reward and staking token.\n     */\n    function exit() external {\n        withdraw(_balances[_msgSender()]);\n        getReward();\n    }\n\n    /**\n     * @notice Change rewards distribution address.\n     * @param _rewardDistribution New rewards distribution address.\n     */\n    function changeRewardsDistribution(address _rewardDistribution) external onlyOwner {\n        rewardsDistribution = _rewardDistribution;\n        emit RewardsDistributionChanged(rewardsDistribution);\n    }\n\n    /**\n     * @notice Transfer rewards token to recipient if distribution not start.\n     * @param recipient Recipient.\n     * @param amount Amount transfered rewards token.\n     */\n    function transfer(address recipient, uint256 amount) external onlyOwner {\n        require(block.number >= periodFinish, \"Staking::transfer: distribution not ended\");\n\n        rewardsToken.safeTransfer(recipient, amount);\n        emit RewardsTransfered(recipient, amount);\n    }\n\n    /**\n     * @notice Change staking end block number.\n     * @param _stakingEndBlock New staking end block number.\n     */\n    function changeStakingEndBlock(uint256 _stakingEndBlock) external onlyOwner {\n        stakingEndBlock = _stakingEndBlock;\n        emit StakingEndBlockChanged(stakingEndBlock);\n    }\n\n    /**\n     * @notice Change unstaking start block number.\n     * @param _unstakingStartBlock New unstaking start block number.\n     */\n    function changeUnstakingStartBlock(uint256 _unstakingStartBlock) external onlyOwner {\n        unstakingStartBlock = _unstakingStartBlock;\n        emit UnstakingStartBlockChanged(unstakingStartBlock);\n    }\n\n    /**\n     * @notice Start distribution.\n     * @param reward Distributed rewards amount.\n     */\n    function notifyRewardAmount(uint256 reward) external updateReward(address(0)) {\n        require(_msgSender() == rewardsDistribution || _msgSender() == owner(), \"Staking::notifyRewardAmount: caller is not RewardsDistribution or Owner address\");\n\n        if (block.number >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.number);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(rewardRate <= balance.div(rewardsDuration), \"Staking::notifyRewardAmount: provided reward too high\");\n\n        lastUpdateBlock = block.number;\n        periodFinish = block.number.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "contracts/ProfitDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./utils/OwnablePausable.sol\";\n\n// solhint-disable max-states-count\ncontract ProfitDistributor is OwnablePausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of rewards distributor.\n    address public rewardsDistribution;\n\n    /// @notice Rewards token address.\n    IERC20 public rewardsToken;\n\n    /// @notice Staking token address.\n    IERC20 public stakingToken;\n\n    /// @notice Block number of rewards distibution period finish.\n    uint256 public periodFinish;\n\n    /// @notice Reward distribution amount per block.\n    uint256 public rewardRate;\n\n    /// @notice Blocks count in current distribution period.\n    uint256 public rewardsDuration;\n\n    /// @notice Block number of last update.\n    uint256 public lastUpdateBlock;\n\n    /// @notice Static reward distribution amount per block.\n    uint256 public rewardPerTokenStored;\n\n    /// @notice Stake lock period.\n    uint256 public lockPeriod;\n\n    /// @notice Stake unlock period.\n    uint256 public unlockPeriod;\n\n    /// @notice Rewards paid.\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    /// @notice Earned rewards.\n    mapping(address => uint256) public rewards;\n\n    /// @dev Total staking token amount.\n    uint256 internal _totalSupply;\n\n    /// @dev Staking balances.\n    mapping(address => uint256) internal _balances;\n\n    /// @dev Block number of stake lock.\n    mapping(address => uint256) internal _stakeAt;\n\n    /// @dev Amount of penalty reward.\n    mapping(address => uint256) internal _penaltyAmount;\n\n    /// @notice An event thats emitted when an reward token addet to contract.\n    event RewardAdded(uint256 reward);\n\n    /// @notice An event thats emitted when an staking token added to contract.\n    event Staked(address indexed user, uint256 amount);\n\n    /// @notice An event thats emitted when an staking token withdrawal from contract.\n    event Withdrawn(address indexed user, uint256 amount);\n\n    /// @notice An event thats emitted when an reward token withdrawal from contract.\n    event RewardPaid(address indexed user, uint256 reward);\n\n    /// @notice An event thats emitted when an rewards distribution address changed.\n    event RewardsDistributionChanged(address newRewardsDistribution);\n\n    /// @notice An event thats emitted when an rewards tokens transfered to recipient.\n    event RewardsTransfered(address recipient, uint256 amount);\n\n    /**\n     * @param _rewardsDistribution Rewards distribution address.\n     * @param _rewardsDuration Duration of distribution.\n     * @param _rewardsToken Address of reward token.\n     * @param _stakingToken Address of staking token.\n     * @param _lockPeriod Stake lock period.\n     * @param _unlockPeriod Stake unlock period.\n     */\n    constructor(\n        address _rewardsDistribution,\n        uint256 _rewardsDuration,\n        address _rewardsToken,\n        address _stakingToken,\n        uint256 _lockPeriod,\n        uint256 _unlockPeriod\n    ) public {\n        rewardsDistribution = _rewardsDistribution;\n        rewardsDuration = _rewardsDuration;\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        lockPeriod = _lockPeriod;\n        unlockPeriod = _unlockPeriod;\n    }\n\n    /**\n     * @notice Update target account rewards state.\n     * @param account Target account.\n     */\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateBlock = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /**\n     * @return Total staking token amount.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @param account Target account.\n     * @return Staking token amount.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lockInfo(address account)\n        public\n        view\n        returns (\n            bool locked,\n            uint256 mod,\n            uint256 nextUnlock,\n            uint256 nextLock,\n            uint256 stakeAt\n        )\n    {\n        stakeAt = _stakeAt[account];\n        uint256 _lockPeriod = lockPeriod; // gas optimisation\n        uint256 _unlockPeriod = unlockPeriod; // gas optimisation\n        if (_lockPeriod > 0) {\n            mod = block.number.sub(stakeAt) % _lockPeriod.add(_unlockPeriod);\n            nextUnlock = block.number.sub(mod).add(_lockPeriod);\n            nextLock = nextUnlock.add(_unlockPeriod);\n            locked = mod < _lockPeriod;\n        }\n    }\n\n    /**\n     * @return Block number of last reward.\n     */\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.number, periodFinish);\n    }\n\n    /**\n     * @return Reward per token.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateBlock).mul(rewardRate).mul(1e18).div(_totalSupply));\n    }\n\n    /**\n     * @param account Target account.\n     * @return Earned rewards.\n     */\n    function earned(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }\n\n    /**\n     * @param account Target account.\n     * @return Penalty rewards.\n     */\n    function penalty(address account) public view returns (uint256) {\n        return _penaltyAmount[account];\n    }\n\n    /**\n     * @return Rewards amount for duration.\n     */\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    /**\n     * @notice Stake token.\n     * @param amount Amount staking token.\n     */\n    function stake(uint256 amount) external whenNotPaused nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ProfitDistributor::stake: cannot stake 0\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[_msgSender()] = _balances[_msgSender()].add(amount);\n        _stakeAt[_msgSender()] = block.number;\n        stakingToken.safeTransferFrom(_msgSender(), address(this), amount);\n        emit Staked(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Withdraw staking token.\n     * @param amount Amount withdraw token.\n     */\n    function withdraw(uint256 amount) internal nonReentrant updateReward(_msgSender()) {\n        require(amount > 0, \"ProfitDistributor::withdraw: Cannot withdraw 0\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[_msgSender()] = _balances[_msgSender()].sub(amount);\n        stakingToken.safeTransfer(_msgSender(), amount);\n        emit Withdrawn(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Withdraw reward token.\n     */\n    function getReward() public nonReentrant updateReward(_msgSender()) {\n        address account = _msgSender();\n        uint256 reward = rewards[account];\n        (bool locked, , , , ) = lockInfo(account);\n        if (locked) {\n            uint256 rewardHalf = reward.div(2);\n            _penaltyAmount[account] = _penaltyAmount[account].add(rewardHalf);\n            reward = reward.sub(rewardHalf);\n        } else {\n            reward = reward.add(_penaltyAmount[account]);\n            _penaltyAmount[account] = 0;\n        }\n\n        if (reward > 0) {\n            rewards[account] = 0;\n            rewardsToken.safeTransfer(account, reward);\n            emit RewardPaid(account, reward);\n        }\n    }\n\n    /**\n     * @notice Withdraw reward and staking token.\n     */\n    function exit() external {\n        address account = _msgSender();\n        withdraw(_balances[account]);\n        getReward();\n\n        uint256 penaltyAmount = _penaltyAmount[account];\n        if (penaltyAmount > 0) {\n            _penaltyAmount[account] = 0;\n            _notifyRewardAmount(penaltyAmount, false);\n        }\n    }\n\n    /**\n     * @notice Change rewards distribution address.\n     * @param _rewardDistribution New rewards distribution address.\n     */\n    function changeRewardsDistribution(address _rewardDistribution) external onlyOwner {\n        rewardsDistribution = _rewardDistribution;\n        emit RewardsDistributionChanged(rewardsDistribution);\n    }\n\n    /**\n     * @notice Update distribution.\n     * @param reward Distributed rewards amount.\n     * @param isUpdatePeriodFinish Is update period finish.\n     */\n    function _notifyRewardAmount(uint256 reward, bool isUpdatePeriodFinish) private updateReward(address(0)) {\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        uint256 _rewardsDuration = rewardsDuration; // gas optimisation\n        if (block.number >= periodFinish) {\n            rewardRate = reward.div(_rewardsDuration);\n            periodFinish = block.number.add(_rewardsDuration);\n\n            require(rewardRate <= balance.div(_rewardsDuration), \"ProfitDistributor::_notifyRewardAmount: provided reward too high\");\n        } else {\n            uint256 remaining = periodFinish.sub(block.number);\n            uint256 leftover = remaining.mul(rewardRate);\n            uint256 period;\n            if (isUpdatePeriodFinish) {\n                period = _rewardsDuration;\n                periodFinish = block.number.add(_rewardsDuration);\n            } else {\n                period = remaining;\n            }\n            rewardRate = reward.add(leftover).div(period);\n\n            require(rewardRate <= balance.div(period), \"ProfitDistributor::_notifyRewardAmount: provided reward too high\");\n        }\n\n        lastUpdateBlock = block.number;\n        emit RewardAdded(reward);\n    }\n\n    /**\n     * @notice Start distribution.\n     * @param reward Distributed rewards amount.\n     */\n    function notifyRewardAmount(uint256 reward) external {\n        address sender = _msgSender();\n        require(sender == rewardsDistribution || sender == owner(), \"ProfitDistributor::notifyRewardAmount: caller is not RewardsDistribution or Owner address\");\n\n        _notifyRewardAmount(reward, true);\n    }\n}\n"
    },
    "contracts/depositary/RealAssetDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"./IDepositaryBalanceView.sol\";\nimport \"./IUpdatable.sol\";\n\ncontract RealAssetDepositaryBalanceView is IDepositaryBalanceView, IUpdatable, AccessControl {\n    using SafeMath for uint256;\n\n    /// @notice Signed data of asset information.\n    struct Proof {\n        string data;\n        string signature;\n    }\n\n    /// @notice Asset information.\n    struct Asset {\n        string id;\n        uint256 amount;\n        uint256 price;\n        uint256 updatedBlockAt;\n    }\n\n    /// @notice The number of assets in depositary.\n    uint256 public maxSize;\n\n    /// @notice Decimals balance.\n    uint256 public override decimals = 6;\n\n    /// @notice Assets list.\n    Asset[] public portfolio;\n\n    /// @dev Assets list index.\n    mapping(string => uint256) internal portfolioIndex;\n\n    /// @notice An event thats emitted when asset updated in portfolio.\n    event AssetUpdated(string id, uint256 updatedAt, Proof proof);\n\n    /// @notice An event thats emitted when asset removed from portfolio.\n    event AssetRemoved(string id);\n\n    /**\n     * @param _decimals Decimals balance.\n     * @param _maxSize Max number assets in depositary.\n     */\n    constructor(uint256 _decimals, uint256 _maxSize) public {\n        decimals = _decimals;\n        maxSize = _maxSize;\n    }\n\n    /**\n     * @return Assets count of depositary.\n     */\n    function size() public view returns (uint256) {\n        return portfolio.length;\n    }\n\n    /**\n     * @return Assets list.\n     */\n    function assets() external view returns (Asset[] memory) {\n        Asset[] memory result = new Asset[](size());\n\n        for (uint256 i = 0; i < size(); i++) {\n            result[i] = portfolio[i];\n        }\n\n        return result;\n    }\n\n    function lastUpdateBlockNumber() external view override returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < size(); i++) {\n            result = portfolio[i].updatedBlockAt > result ? portfolio[i].updatedBlockAt : result;\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Update information of asset.\n     * @param id Asset identificator.\n     * @param amount Amount of asset.\n     * @param price Cost of one asset in base currency.\n     * @param updatedAt Timestamp of updated.\n     * @param proofData Signed data.\n     * @param proofSignature Data signature.\n     */\n    function put(\n        string calldata id,\n        uint256 amount,\n        uint256 price,\n        uint256 updatedAt,\n        string calldata proofData,\n        string calldata proofSignature\n    ) external onlyAllowed {\n        require(size() < maxSize, \"RealAssetDepositaryBalanceView::put: too many assets\");\n\n        uint256 valueIndex = portfolioIndex[id];\n        if (valueIndex != 0) {\n            portfolio[valueIndex.sub(1)] = Asset(id, amount, price, block.number);\n        } else {\n            portfolio.push(Asset(id, amount, price, block.number));\n            portfolioIndex[id] = size();\n        }\n        emit AssetUpdated(id, updatedAt, Proof(proofData, proofSignature));\n    }\n\n    /**\n     * @notice Remove information of asset.\n     * @param id Asset identificator.\n     */\n    function remove(string calldata id) external onlyAllowed {\n        uint256 valueIndex = portfolioIndex[id];\n        require(valueIndex != 0, \"RealAssetDepositaryBalanceView::remove: asset already removed\");\n\n        uint256 toDeleteIndex = valueIndex.sub(1);\n        uint256 lastIndex = size().sub(1);\n        Asset memory lastValue = portfolio[lastIndex];\n        portfolio[toDeleteIndex] = lastValue;\n        portfolioIndex[lastValue.id] = toDeleteIndex.add(1);\n        portfolio.pop();\n        delete portfolioIndex[id];\n\n        emit AssetRemoved(id);\n    }\n\n    function balance() external view override returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < size(); i++) {\n            result = result.add(portfolio[i].amount.mul(portfolio[i].price));\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/depositary/IUpdatable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IUpdatable {\n    /**\n     * @return Last update block number.\n     */\n    function lastUpdateBlockNumber() external view returns (uint256);\n}\n"
    },
    "contracts/alert/DepositaryUpdateValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./IValidator.sol\";\nimport \"../depositary/IUpdatable.sol\";\n\ncontract DepositaryUpdateValidator is IValidator, Ownable {\n    using SafeMath for uint256;\n\n    /// @notice Depositary address.\n    address public depositary;\n\n    /// @notice Number of blocks from current.\n    uint256 public blockLimit;\n\n    /// @notice An event thats emitted when depositary address updated.\n    event DepositaryUpdated(address newDepositary);\n\n    /// @notice An event thats emitted when block limit updated.\n    event BlockLimitUpdated(uint256 newBlockLimit);\n\n    /**\n     * @param _depositary Depositary address.\n     * @param _blockLimit Number of blocks from current.\n     */\n    constructor(address _depositary, uint256 _blockLimit) public {\n        depositary = _depositary;\n        blockLimit = _blockLimit;\n    }\n\n    /**\n     * @notice Update depositary address.\n     * @param _depositary New depositary address.\n     */\n    function changeDepositary(address _depositary) external onlyOwner {\n        require(_depositary != address(0), \"DepositaryUpdateValidator::changeDepositary: invalid depositary address\");\n\n        depositary = _depositary;\n        emit DepositaryUpdated(_depositary);\n    }\n\n    /**\n     * @notice Update block limit.\n     * @param _blockLimit New block limit.\n     */\n    function changeBlockLimit(uint256 _blockLimit) external onlyOwner {\n        blockLimit = _blockLimit;\n        emit BlockLimitUpdated(_blockLimit);\n    }\n\n    function validate() external view override returns (bool) {\n        uint256 depositaryUpdatedAt = IUpdatable(depositary).lastUpdateBlockNumber();\n\n        return depositaryUpdatedAt == 0 || block.number.sub(blockLimit) <= depositaryUpdatedAt;\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./utils/AccessControl.sol\";\n\ncontract Treasury is AccessControl {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    receive() external payable {}\n\n    /**\n     * @notice Transfer target token to recipient.\n     * @param token Target token.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transfer(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyAllowed returns (bool) {\n        ERC20(token).safeTransfer(recipient, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer ETH to recipient.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transferETH(address payable recipient, uint256 amount) external onlyAllowed returns (bool) {\n        recipient.transfer(amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve target token to recipient.\n     * @param token Target token.\n     * @param recipient Recipient.\n     * @param amount Approve amount.\n     */\n    function approve(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyAllowed returns (bool) {\n        uint256 allowance = ERC20(token).allowance(address(this), recipient);\n        if (allowance > 0) {\n            ERC20(token).safeApprove(recipient, 0);\n        }\n        ERC20(token).safeApprove(recipient, amount);\n        return true;\n    }\n}\n"
    },
    "contracts/CollateralMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./Issuer.sol\";\nimport \"./Treasury.sol\";\n\ncontract CollateralMarket is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Address of issuer contract.\n    Issuer public issuer;\n\n    /// @notice Address of treasury contract.\n    Treasury public treasury;\n\n    /// @notice Address of depositary contract.\n    address public depositary;\n\n    /// @dev Allowed tokens list.\n    EnumerableSet.AddressSet private _allowedTokens;\n\n    /// @notice An event emitted when token allowed.\n    event TokenAllowed(address token);\n\n    /// @notice An event emitted when token denied.\n    event TokenDenied(address token);\n\n    /// @notice An event thats emitted when an Issuer contract address changed.\n    event IssuerChanged(address newIssuer);\n\n    /// @notice An event thats emitted when an Treasury contract address changed.\n    event TreasuryChanged(address newTreasury);\n\n    /// @notice An event thats emitted when an Depositary contract address changed.\n    event DepositaryChanged(address newDepositary);\n\n    /// @notice An event thats emitted when an account buyed token.\n    event Buy(address customer, address token, uint256 amount, uint256 buy);\n\n    constructor(\n        address _issuer,\n        address payable _treasury,\n        address _depositary\n    ) public {\n        issuer = Issuer(_issuer);\n        treasury = Treasury(_treasury);\n        depositary = _depositary;\n    }\n\n    /**\n     * @notice Allow token.\n     * @param token Allowable token.\n     */\n    function allowToken(address token) external onlyOwner {\n        _allowedTokens.add(token);\n        emit TokenAllowed(token);\n    }\n\n    /**\n     * @notice Deny token.\n     * @param token Denied token.\n     */\n    function denyToken(address token) external onlyOwner {\n        _allowedTokens.remove(token);\n        emit TokenDenied(token);\n    }\n\n    /**\n     * @return Allowed tokens list.\n     */\n    function allowedTokens() external view returns (address[] memory) {\n        address[] memory result = new address[](_allowedTokens.length());\n\n        for (uint256 i = 0; i < _allowedTokens.length(); i++) {\n            result[i] = _allowedTokens.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Change Issuer contract address.\n     * @param _issuer New address Issuer contract.\n     */\n    function changeIssuer(address _issuer) external onlyOwner {\n        issuer = Issuer(_issuer);\n        emit IssuerChanged(_issuer);\n    }\n\n    /**\n     * @notice Change Treasury contract address.\n     * @param _treasury New address Treasury contract.\n     */\n    function changeTreasury(address payable _treasury) external onlyOwner {\n        treasury = Treasury(_treasury);\n        emit TreasuryChanged(_treasury);\n    }\n\n    /**\n     * @notice Change Depositary contract address.\n     * @param _depositary New address Depositary contract.\n     */\n    function changeDepositary(address _depositary) external onlyOwner {\n        require(issuer.hasDepositary(_depositary), \"CollateralMarket::changeDepositary: collateral depositary is not allowed\");\n        depositary = _depositary;\n        emit DepositaryChanged(depositary);\n    }\n\n    /**\n     * @notice Buy stable token with ERC20 payment token amount.\n     * @param token Payment token.\n     * @param amount Amount of payment token.\n     */\n    function buy(ERC20 token, uint256 amount) external whenNotPaused {\n        require(_allowedTokens.contains(address(token)), \"CollateralMarket::buy: token is not allowed\");\n        require(issuer.hasDepositary(depositary), \"CollateralMarket::buy: collateral depositary is not allowed\");\n\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n        token.transfer(depositary, amount);\n\n        ERC20 stableToken = ERC20(issuer.stableToken());\n        uint256 stableTokenDecimals = stableToken.decimals();\n        uint256 tokenDecimals = token.decimals();\n        uint256 reward = amount.mul(10**(stableTokenDecimals.sub(tokenDecimals)));\n        issuer.rebalance();\n        treasury.transfer(address(stableToken), _msgSender(), reward);\n\n        emit Buy(_msgSender(), address(token), amount, reward);\n    }\n}\n"
    },
    "contracts/depositary/CurveDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../curve/IRegistry.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\nimport \"./IDepositaryBalanceView.sol\";\nimport \"../curve/IPool.sol\";\nimport \"../curve/ILiquidityGauge.sol\";\nimport \"../curve/IMinter.sol\";\n\ncontract CurveDepositaryBalanceView is Ownable, IDepositaryBalanceView {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Curve registry contract.\n    IRegistry public registry;\n\n    /// @notice Uniswap router contract.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @dev Invested pools.\n    EnumerableSet.AddressSet private pools;\n\n    /// @notice Balance decimals.\n    uint256 public override decimals = 18;\n\n    /// @dev Invested balances.\n    mapping(address => uint256) internal balances;\n\n    /// @notice An event thats emitted when an curve registry address changed.\n    event RegistryChanged(address registry);\n\n    /// @notice An event thats emitted when an uniswap router address changed.\n    event UniswapRouterChanged(address uniswapRouter);\n\n    /// @notice An event thats emitted when an invested token.\n    event Invested(address pool, address token, uint256 amount);\n\n    /// @notice An event thats emitted when an withdrawal token.\n    event Withdrawal(address token, uint256 amount, address recipient);\n\n    /// @notice An event thats emitted when an withdrawal proft token.\n    event Mint(address token, uint256 amount, address recipient);\n\n    /**\n     * @param _registry Curve registry contract address.\n     * @param _uniswapRouter Uniswap router contract address.\n     */\n    constructor(address _registry, address _uniswapRouter) public {\n        registry = IRegistry(_registry);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @param _registry New Curve registry contract address.\n     */\n    function changeRegistry(address _registry) external onlyOwner {\n        require(_registry != address(0), \"CurveDepositaryBalanceView::changeRegistry: invalid registry address\");\n\n        registry = IRegistry(_registry);\n        emit RegistryChanged(_registry);\n    }\n\n    /**\n     * @param _uniswapRouter New Uniswap router contract address.\n     */\n    function changeUniswap(address _uniswapRouter) external onlyOwner {\n        require(_uniswapRouter != address(0), \"CurveDepositaryBalanceView::changeUniswap: invalid uniswap address\");\n\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @param pool Target liquidity pool address.\n     * @return Liquidity pool token.\n     */\n    function _getPoolLiquidityToken(address pool) internal view returns (ERC20) {\n        address tokenAddress = registry.get_lp_token(pool);\n        require(tokenAddress != address(0), \"CurveDepositaryBalanceView::_getPoolLiquidityToken: liquidity token not found\");\n\n        return ERC20(tokenAddress);\n    }\n\n    /**\n     * @param pool Target liquidity pool address.\n     * @return Liquidity gauge.\n     */\n    function _getPoolLiquidityGauge(address pool) internal view returns (ILiquidityGauge) {\n        (address[10] memory gauges, ) = registry.get_gauges(pool);\n        require(gauges[0] != address(0), \"CurveDepositaryBalanceView::_getPoolLiquidityGauge: liquidity gauge not found\");\n\n        return ILiquidityGauge(gauges[0]);\n    }\n\n    /**\n     * @param pool Invested pool.\n     * @return Balance of invested pool.\n     */\n    function balanceOf(address pool) external view returns (uint256) {\n        return balances[pool];\n    }\n\n    /**\n     * @notice Lock all liquidity pool token in liquidity gauge.\n     * @param pool Target liquidity pool address.\n     */\n    function _lock(address pool) internal {\n        ILiquidityGauge gauge = _getPoolLiquidityGauge(pool);\n        ERC20 lpToken = _getPoolLiquidityToken(pool);\n        uint256 balance = lpToken.balanceOf(address(this));\n        if (balance == 0) return;\n\n        lpToken.safeApprove(address(gauge), 0);\n        lpToken.safeApprove(address(gauge), balance);\n        gauge.deposit(balance);\n    }\n\n    /**\n     * @notice Unlock all liquidity pool token from liquidity gauge.\n     * @param pool Target liquidity pool address.\n     */\n    function _unlock(address pool) internal {\n        ILiquidityGauge gauge = _getPoolLiquidityGauge(pool);\n        uint256 balance = ERC20(address(gauge)).balanceOf(address(this));\n\n        gauge.withdraw(balance);\n    }\n\n    /**\n     * @notice Mint CRV tokens and swap to target token.\n     * @param pool Target liquidity pool.\n     * @param toToken Target token.\n     * @param recipient Recipient.\n     */\n    function mint(\n        address pool,\n        address toToken,\n        address recipient\n    ) public onlyOwner {\n        require(toToken != address(0), \"CurveDepositaryBalanceView::mintCrv: invalid target token address\");\n\n        ILiquidityGauge gauge = _getPoolLiquidityGauge(pool);\n        IMinter minter = IMinter(gauge.minter());\n        minter.mint(address(gauge));\n\n        ERC20 crv = ERC20(minter.token());\n        uint256 crvBalance = crv.balanceOf(address(this));\n        if (crvBalance == 0) return;\n\n        if (toToken != address(crv)) {\n            address[] memory path = new address[](2);\n            path[0] = address(address(crv));\n            path[1] = address(toToken);\n\n            uint256[] memory amountsOut = uniswapRouter.getAmountsOut(crvBalance, path);\n            require(amountsOut.length == 2, \"CurveDepositaryBalanceView::mintCrv: invalid amount out\");\n            uint256 amountOut = amountsOut[amountsOut.length - 1];\n            require(amountOut > 0, \"CurveDepositaryBalanceView::mintCrv: liquidity pool is empty\");\n\n            crv.safeApprove(address(uniswapRouter), 0);\n            crv.safeApprove(address(uniswapRouter), crvBalance);\n            uint256[] memory profitAmount = uniswapRouter.swapExactTokensForTokens(crvBalance, amountOut, path, recipient, block.timestamp);\n\n            emit Mint(toToken, profitAmount[profitAmount.length - 1], recipient);\n        } else {\n            crv.safeTransfer(recipient, crvBalance);\n            emit Mint(address(crv), crvBalance, recipient);\n        }\n    }\n\n    /**\n     * @notice Invest token to Curve.\n     * @param pool Target liquidity pool.\n     * @param tokenIndex Invested token index in the pool. Target ERC20 token should be approved to contract before call.\n     * @param amount Amount of invested token.\n     */\n    function invest(\n        address pool,\n        uint256 tokenIndex,\n        uint256 amount\n    ) external onlyOwner {\n        require(amount > 0, \"CurveDepositaryBalanceView::invest: invalid amount\");\n        require(tokenIndex < 3, \"CurveDepositaryBalanceView::invest: invalid token index\");\n\n        address tokenAddress = IPool(pool).coins(tokenIndex);\n        require(tokenAddress != address(0), \"CurveDepositaryBalanceView::invest: invalid invest token\");\n\n        ERC20 token = ERC20(tokenAddress);\n        uint256 tokenDecimals = token.decimals();\n        require(tokenDecimals <= decimals, \"CurveDepositaryBalanceView::invest: invalid token decimals\");\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        balances[pool] = balances[pool].add(amount.mul(10**(decimals.sub(tokenDecimals)))); // Only stable token sum\n        pools.add(pool);\n\n        token.safeApprove(pool, 0);\n        token.safeApprove(pool, amount);\n        uint256[3] memory deposit;\n        deposit[tokenIndex] = amount;\n        IPool(pool).add_liquidity(deposit, 0);\n        _lock(pool);\n\n        emit Invested(pool, tokenAddress, amount);\n    }\n\n    /**\n     * @notice Withdraw invested token and reward.\n     * @param pool Target liquidity pool.\n     * @param tokenIndex Invested token index in the pool.\n     * @param recipient Recipient of invested token.\n     */\n    function withdraw(\n        address pool,\n        uint256 tokenIndex,\n        address recipient\n    ) external onlyOwner {\n        require(tokenIndex < 3, \"CurveDepositaryBalanceView::invest: invalid token index\");\n\n        address tokenAddress = IPool(pool).coins(tokenIndex);\n        require(tokenAddress != address(0), \"CurveDepositaryBalanceView::withdraw: invalid withdraw token\");\n        ERC20 lpToken = _getPoolLiquidityToken(pool);\n\n        balances[pool] = 0;\n        pools.remove(pool);\n\n        _unlock(pool);\n        uint256 lpBalance = lpToken.balanceOf(address(this));\n        IPool(pool).remove_liquidity_one_coin(lpBalance, int128(tokenIndex), 0);\n\n        ERC20 token = ERC20(tokenAddress);\n        uint256 balance = token.balanceOf(address(this));\n        token.safeTransfer(recipient, balance);\n\n        emit Withdrawal(tokenAddress, balance, recipient);\n    }\n\n    /**\n     * @return Invested liquidity pools.\n     */\n    function investedPools() external view returns (address[] memory) {\n        address[] memory result = new address[](pools.length());\n\n        for (uint256 i = 0; i < pools.length(); i++) {\n            result[i] = pools.at(i);\n        }\n\n        return result;\n    }\n\n    function balance() external view override returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < pools.length(); i++) {\n            address pool = pools.at(i);\n            result = result.add(balances[pool]);\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/curve/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IRegistry {\n    function get_lp_token(address pool) external view returns (address);\n\n    function get_gauges(address pool) external view returns (address[10] memory, int128[10] memory);\n}\n"
    },
    "contracts/curve/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IPool {\n    function coins(uint256 i) external view returns (address);\n\n    function add_liquidity(uint256[3] memory _deposit_amounts, uint256 _min_mint_amount) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external;\n}\n"
    },
    "contracts/curve/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface ILiquidityGauge {\n    function minter() external view returns (address);\n\n    function crv_token() external view returns (address);\n\n    function claimable_tokens(address recipient) external returns (uint256);\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/curve/IMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IMinter {\n    function token() external view returns (address);\n\n    function minted(address recipient, address gauge) external view returns (uint256);\n\n    function mint(address gauge_addr) external;\n}\n"
    },
    "contracts/depositary/CompoundDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./IDepositaryBalanceView.sol\";\n\ncontract CompoundDepositaryBalanceView is Ownable, IDepositaryBalanceView {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Invested cTokens.\n    EnumerableSet.AddressSet private tokens;\n\n    /// @notice Balance decimals.\n    uint256 public override decimals = 18;\n\n    /// @dev Invested balances.\n    mapping(address => uint256) internal balances;\n\n    /// @notice An event thats emitted when an invested token.\n    event Invested(address cToken, uint256 amount);\n\n    /// @notice An event thats emitted when an withdrawal token.\n    event Withdrawal(address cToken, uint256 amount, uint256 profit, address investRecipient, address profitRecipient);\n\n    /**\n     * @param cToken Invested cToken.\n     * @return Balance of invested token.\n     */\n    function balanceOf(address cToken) external view returns (uint256) {\n        return balances[cToken];\n    }\n\n    /**\n     * @notice Invest token to Compound.\n     * @param cToken Invested cToken. Target ERC20 token should be approved to contract before call.\n     * @param amount Amount of invested token.\n     */\n    function invest(address cToken, uint256 amount) external onlyOwner {\n        require(amount > 0, \"CompoundDepositaryBalanceView::invest: invalid amount\");\n\n        ERC20 token = ERC20(CToken(cToken).underlying());\n        uint256 tokenDecimals = token.decimals();\n        require(tokenDecimals <= decimals, \"CompoundDepositaryBalanceView::invest: invalid token decimals\");\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        token.safeApprove(cToken, 0);\n        token.safeApprove(cToken, amount);\n        CToken(cToken).mint(amount);\n        balances[cToken] = balances[cToken].add(amount);\n        tokens.add(cToken);\n        emit Invested(cToken, amount);\n    }\n\n    /**\n     * @notice Withdraw invested token and reward.\n     * @param cToken Invested cToken.\n     * @param investRecipient Recipient of invested token.\n     * @param profitRecipient Recipient of reward token.\n     */\n    function withdraw(\n        address cToken,\n        address investRecipient,\n        address profitRecipient\n    ) external onlyOwner {\n        uint256 investAmount = balances[cToken];\n        require(investAmount > 0, \"CompoundDepositaryBalanceView::withdraw: token not invested\");\n\n        balances[cToken] = 0;\n        tokens.remove(cToken);\n\n        uint256 cTokenBalance = ERC20(cToken).balanceOf(address(this));\n        CToken(cToken).redeem(cTokenBalance);\n\n        ERC20 token = ERC20(CToken(cToken).underlying());\n        uint256 balance = token.balanceOf(address(this));\n        uint256 profitAmount;\n        if (balance >= investAmount) {\n            profitAmount = balance.sub(investAmount);\n        } else {\n            investAmount = balance;\n        }\n\n        token.safeTransfer(investRecipient, investAmount);\n        if (profitAmount > 0) {\n            token.safeTransfer(profitRecipient, profitAmount);\n        }\n\n        emit Withdrawal(cToken, investAmount, profitAmount, investRecipient, profitRecipient);\n    }\n\n    /**\n     * @return Invested cTokens.\n     */\n    function investedTokens() external view returns (address[] memory) {\n        address[] memory result = new address[](tokens.length());\n\n        for (uint256 i = 0; i < tokens.length(); i++) {\n            result[i] = tokens.at(i);\n        }\n\n        return result;\n    }\n\n    function balance() external view override returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < tokens.length(); i++) {\n            address cToken = tokens.at(i);\n            ERC20 token = ERC20(CToken(cToken).underlying());\n            uint256 tokenDecimals = token.decimals();\n\n            result = result.add(balances[cToken].mul(10**(decimals.sub(tokenDecimals))));\n        }\n\n        return result;\n    }\n}\n\nabstract contract CToken {\n    address public underlying;\n\n    function exchangeRateCurrent() public virtual returns (uint256);\n\n    function mint(uint256 mintAmount) external virtual returns (uint256);\n\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n}\n"
    },
    "contracts/depositary/DepositorCollateral.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\ncontract DepositorCollateral is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Max number of depositors.\n    uint256 public maxSize;\n\n    /**\n     * @notice Locked tokens.\n     */\n    mapping(address => uint256) public totalSupply;\n\n    /**\n     * @dev Depositors list.\n     */\n    mapping(address => EnumerableSet.AddressSet) internal _depositors;\n\n    /**\n     * @dev Depositors balances.\n     */\n    mapping(address => mapping(address => uint256)) internal _balances;\n\n    /// @notice An event emitted when collateral locked.\n    event Lock(address token, address depositor, uint256 amount);\n\n    /// @notice An event emitted when collateral withdraw.\n    event Withdraw(address token, address depositor, uint256 amount);\n\n    /**\n     * @param _maxSize Max number of depositors.\n     */\n    constructor(uint256 _maxSize) public {\n        maxSize = _maxSize;\n    }\n\n    /**\n     * @notice Get depositors.\n     * @param token Collateral token.\n     * @return Addresses of all depositors.\n     */\n    function getDepositors(address token) public view returns (address[] memory) {\n        address[] memory result = new address[](_depositors[token].length());\n\n        for (uint256 i = 0; i < _depositors[token].length(); i++) {\n            result[i] = _depositors[token].at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Get balance of depositor.\n     * @param token Target token.\n     * @param depositor Target depositor.\n     * @return Balance of depositor.\n     */\n    function balanceOf(address token, address depositor) public view returns (uint256) {\n        return _balances[token][depositor];\n    }\n\n    /**\n     * @notice Lock depositor collateral.\n     * @param token Locked token.\n     * @param depositor Depositor address.\n     * @param amount Locked amount.\n     */\n    function lock(\n        address token,\n        address depositor,\n        uint256 amount\n    ) external onlyOwner {\n        require(amount > 0, \"DepositorCollateral::lock: empty amount\");\n        _depositors[token].add(depositor);\n        require(_depositors[token].length() <= maxSize, \"DepositorCollateral::lock: too many depositors\");\n\n        ERC20(token).safeTransferFrom(depositor, address(this), amount);\n        _balances[token][depositor] = _balances[token][depositor].add(amount);\n        totalSupply[token] = totalSupply[token].add(amount);\n        emit Lock(token, depositor, amount);\n    }\n\n    /**\n     * @notice Withdraw depositor collateral.\n     * @param token Withdraw token.\n     * @param depositor Depositor address.\n     * @param amount Withdraw amount.\n     */\n    function withdraw(\n        address token,\n        address depositor,\n        uint256 amount\n    ) external onlyOwner {\n        require(amount > 0, \"DepositorCollateral::withdraw: empty amount\");\n        require(balanceOf(token, depositor) >= amount, \"DepositorCollateral::withdraw: negative balance\");\n\n        _balances[token][depositor] = _balances[token][depositor].sub(amount);\n        if (_balances[token][depositor] == 0) {\n            _depositors[token].remove(depositor);\n        }\n        totalSupply[token] = totalSupply[token].sub(amount);\n        ERC20(token).safeTransfer(depositor, amount);\n        emit Withdraw(token, depositor, amount);\n    }\n}\n"
    },
    "contracts/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Timelock {\n    using SafeMath for uint256;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor(address admin_, uint256 delay_) public {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function __transferAdmin(address _newAdmin) public {\n        require(msg.sender == admin, \"Timelock::__transferAdmin: caller is not the admin\");\n        admin = _newAdmin;\n\n        emit NewAdmin(admin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/Budget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./utils/OwnablePausable.sol\";\n\ncontract Budget is OwnablePausable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Expenditure item.\n    struct Expenditure {\n        address recipient;\n        uint256 min;\n        uint256 target;\n    }\n\n    /// @notice Expenditure item to address.\n    mapping(address => Expenditure) public expenditures;\n\n    /// @dev Recipients addresses list.\n    EnumerableSet.AddressSet internal recipients;\n\n    /// @dev Withdrawal balance of recipients.\n    mapping(address => uint256) internal balances;\n\n    /// @notice Total withdrawal balance.\n    uint256 public totalSupply;\n\n    /// @notice An event emitted when expenditure item changed.\n    event ExpenditureChanged(address recipient, uint256 min, uint256 target);\n\n    /// @notice An event emitted when expenditure item payed.\n    event Payed(address recipient, uint256 amount);\n\n    receive() external payable {}\n\n    /**\n     * @notice Change expenditure item.\n     * @param recipient Recipient address.\n     * @param min Minimal balance for payment.\n     * @param target Target balance.\n     */\n    function changeExpenditure(\n        address recipient,\n        uint256 min,\n        uint256 target\n    ) external onlyOwner {\n        require(min <= target, \"Budget::changeExpenditure: minimal balance should be less or equal target balance\");\n\n        expenditures[recipient] = Expenditure(recipient, min, target);\n        if (target > 0) {\n            recipients.add(recipient);\n        } else {\n            recipients.remove(recipient);\n        }\n        emit ExpenditureChanged(recipient, min, target);\n    }\n\n    /**\n     * @notice Get withdrawal balance of recipient.\n     */\n    function balanceOf(address recipient) public view returns (uint256) {\n        return balances[recipient];\n    }\n\n    /**\n     * @notice Transfer ETH to recipient.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transferETH(address payable recipient, uint256 amount) external onlyOwner {\n        require(address(this).balance.sub(totalSupply) >= amount, \"Budget::transferETH: transfer amount exceeds balance\");\n\n        recipient.transfer(amount);\n    }\n\n    /**\n     * @notice Return all recipients addresses.\n     * @return Recipients addresses.\n     */\n    function getRecipients() external view returns (address[] memory) {\n        address[] memory result = new address[](recipients.length());\n\n        for (uint256 i = 0; i < recipients.length(); i++) {\n            result[i] = recipients.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Return balance deficit of recipient.\n     * @param recipient Target recipient.\n     * @return Balance deficit of recipient.\n     */\n    function deficitTo(address recipient) public view returns (uint256) {\n        require(recipients.contains(recipient), \"Budget::deficitTo: recipient not in expenditure item\");\n\n        uint256 availableBalance = recipient.balance.add(balanceOf(recipient));\n        if (availableBalance > expenditures[recipient].min) return 0;\n\n        return expenditures[recipient].target.sub(availableBalance);\n    }\n\n    /**\n     * @notice Return summary balance deficit of all recipients.\n     * @return Summary balance deficit of all recipients.\n     */\n    function deficit() public view returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < recipients.length(); i++) {\n            result = result.add(deficitTo(recipients.at(i)));\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Pay ETH to all recipients with balance deficit.\n     */\n    function pay() external {\n        for (uint256 i = 0; i < recipients.length(); i++) {\n            uint256 budgetBalance = address(this).balance.sub(totalSupply);\n            address recipient = recipients.at(i);\n            uint256 amount = deficitTo(recipient);\n            if (amount == 0 || budgetBalance < amount) continue;\n\n            balances[recipient] = balanceOf(recipient).add(amount);\n            totalSupply = totalSupply.add(amount);\n        }\n    }\n\n    /**\n     * @notice Withdraw ETH to recipient.\n     */\n    function withdraw() external {\n        address payable recipient = _msgSender();\n        uint256 amount = balanceOf(recipient);\n        require(amount > 0, \"Budget::withdraw: transfer amount exceeds balance\");\n\n        balances[recipient] = 0;\n        totalSupply = totalSupply.sub(amount);\n        recipient.transfer(amount);\n        emit Payed(recipient, amount);\n    }\n}\n"
    },
    "contracts/chainlink/CrossPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"./IPriceFeed.sol\";\n\nlibrary CrossPriceFeed {\n    using SignedSafeMath for int256;\n\n    /**\n     * @param path Price feeds chain.\n     * @param amountIn Input amount.\n     * @return amounts Output amount of all price feeds.\n     */\n    function getAmountsOut(address[] memory path, int256 amountIn) internal view returns (int256[] memory amounts) {\n        require(path.length > 0, \"ChainlinkCrossPriceFeed: invalid path\");\n\n        amounts = new int256[](path.length + 1);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length; i++) {\n            IPriceFeed priceFeed = IPriceFeed(path[i]);\n            uint8 decimals = priceFeed.decimals();\n            (, int256 price, , , ) = priceFeed.latestRoundData();\n\n            amounts[i + 1] = amounts[i].mul(price).div(int128(10)**decimals);\n        }\n    }\n\n    /**\n     * @param path Price feeds chain.\n     * @param amountIn Input amount.\n     * @return Output amount of latest price feed.\n     */\n    function getAmountOut(address[] memory path, int256 amountIn) internal view returns (int256) {\n        return getAmountsOut(path, amountIn)[path.length];\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/chainlink/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IPriceFeed {\n    function decimals() external view returns (uint8);\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function version() external view returns (uint256);\n}"
    },
    "contracts/chainlink/PriceFeedMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./IPriceFeed.sol\";\n\ncontract PriceFeedMock is IPriceFeed {\n    uint8 override public decimals;\n\n    uint256 override public version;\n\n    struct Round {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n\n    mapping(uint80 => Round) internal _rounds;\n\n    uint80 public latestRoundId;\n\n    constructor(uint8 _decimals, uint256 _version) public {\n        decimals = _decimals;\n        version = _version;\n    }\n\n    function addRound(\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) public {\n        _rounds[++latestRoundId] = Round(roundId, answer, startedAt, updatedAt, answeredInRound);\n    }\n\n    function getRoundData(uint80 _roundId)\n        override\n        public\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = _rounds[_roundId].roundId;\n        answer = _rounds[_roundId].answer;\n        startedAt = _rounds[_roundId].startedAt;\n        updatedAt = _rounds[_roundId].updatedAt;\n        answeredInRound = _rounds[_roundId].answeredInRound;\n    }\n\n    function latestRoundData()\n        override\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return getRoundData(latestRoundId);\n    }\n}\n"
    },
    "contracts/GovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ncontract GovernorAlpha {\n    /// @notice The name of this contract\n    string public constant name = \"BondAppetit Governor Alpha\";\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint256) {\n        return 4000000e18;\n    } // 4,000,000 = 4% of governance token\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    function proposalThreshold() public pure returns (uint256) {\n        return 1000000e18;\n    } // 1,000,000 = 1% of governance token\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint256) {\n        return 10;\n    } // 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint256) {\n        return 1;\n    } // 1 block\n\n    /// @notice The duration of voting on a proposal, in blocks\n    function votingPeriod() public pure returns (uint256) {\n        return 17280;\n    } // ~3 days in blocks (assuming 15s blocks)\n\n    /// @notice The address of the Timelock contract\n    TimelockInterface public timelock;\n\n    /// @notice The address of the governance token\n    GovernanceTokenInterface public governanceToken;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // Creator of the proposal\n        address proposer;\n        // The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        // the ordered list of target addresses for calls to be made\n        address[] targets;\n        // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        // The ordered list of function signatures to be called\n        string[] signatures;\n        // The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        // The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        // The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        // Current number of votes in favor of this proposal\n        uint256 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n        // Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal\n        bool support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(uint256 id, address proposer, address[] targets, uint256[] values, string[] signatures, bytes[] calldatas, uint256 startBlock, uint256 endBlock, string description);\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    constructor(\n        address _timelock,\n        address _governanceToken,\n        address _guardian\n    ) public {\n        timelock = TimelockInterface(_timelock);\n        governanceToken = GovernanceTokenInterface(_governanceToken);\n        guardian = _guardian;\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        require(governanceToken.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint256 startBlock = add256(block.number, votingDelay());\n        uint256 endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            startBlock: startBlock,\n            endBlock: endBlock,\n            forVotes: 0,\n            againstVotes: 0,\n            canceled: false,\n            executed: false\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }\n\n    function queue(uint256 proposalId) public {\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = add256(block.timestamp, timelock.delay());\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function _queueOrRevert(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function execute(uint256 proposalId) public payable {\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    function cancel(uint256 proposalId) public {\n        ProposalState state = state(proposalId);\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == guardian || governanceToken.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    function getActions(uint256 proposalId)\n        public\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }\n\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = governanceToken.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) {\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    function __acceptAdmin() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    }\n\n    function __abdicate() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    }\n\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }\n\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"subtraction underflow\");\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\ninterface TimelockInterface {\n    function delay() external view returns (uint256);\n\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n\ninterface GovernanceTokenInterface {\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n}\n"
    },
    "contracts/uniswap/IUniswapAnchoredView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IUniswapAnchoredView {\n    function price(string calldata symbol) external view returns (uint);\n}"
    },
    "contracts/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}